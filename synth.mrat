;; for map, reduce, etc.
;;(load-file "./examples/functional.mrat")
(load-file "./examples/core.mrat")
(load-file "./examples/notes.mrat")
(load-file "./examples/welsh.mrat")

(def myMetroConfig
  (list :osc (list (list :key :osc1
                         :wave :tri
                         :duty 0.05
                         :mix 1)
                   (list :key :osc2
                         :wave :sqr
                         :duty 0.5
                         :detune (cents 10)
                         :mix 0.65))
        :lfo (list :route '(:osc1 :freq :osc2 :freq)
                   :wave :tri
                   :freq 2.4
                   :depth (list :freq (cents 10)))
        :lpf (list :cutoff 500
                   :res 0.85)
        :amp (list :attack 0.01
                   :decay  0
                   :sustain 1
                   :release 0.1)))
(def myMetro (mkwelsh myMetroConfig))

(def (second lst) (first (rest lst)))

(def (even? n)
  (let ((half (/ n 2)))
    (= half (floor half))))
(def (odd? n)
  (not (even? n)))

(def (~mixer)
  (let ((mixerArgs $args))
    (let ((weightSum (reduce +
                             (map-idx (fn (val idx) (if (even? idx) val 0)) mixerArgs)
                             0)))
      (sum (map (fn (idx) (let ((weight (nth mixerArgs (* 2 idx)))
                                (chan   (nth mixerArgs (+ (* 2 idx) 1))))
                            (* (/ weight weightSum) chan)))
                (range 0 (/ (length mixerArgs) 2)))))))

(def (avg lst)
  (* (sum lst)
     (/ 1 (length lst))))

(def (meandering-sound lfo-freq-n lfo-rate)
  (let ((frequency-multiples (range 1 lfo-freq-n)))
    (let ((~sins
           (fn (fundamental)
             (avg (map
                   (fn (x) (* (/ 1.0 1.0) (~pulse (* fundamental x))))
                   frequency-multiples)))))
      (let ((~lfo (~sins lfo-rate)))
        (~saw (remap ~lfo 100 1000) :duty (remap ~lfo 0.1 0.9))))))

(def sample-rate 44100)

;;(def niegalo-sample-raw (open-file "/Users/jfhamlin/Movies/Twitch Studio/niegalo_todo.wav"))

;; (def (buffer-time-range buffer start-time end-time)
;;   (let ((start-sample (floor (* start-time sample-rate)))
;;         (end-sample (floor (* end-time sample-rate))))
;;     (subvec buffer start-sample end-sample)))

;; (def niegalo-sample (buffer-time-range niegalo-sample-raw 18 126))

;; (def (half-speed samples)
;;   (map (fn (i) (let ((samp1 (samples (floor (/ i 2))))
;;                      (samp2 (samples (floor (/ (+ i 1) 2)))))
;;                  (/ (+ samp1 samp2) 2)))
;;        (range 0 (- (* 2 (length samples)) 1))))

;; (def (tri-delay ~in freq)
;;   (~delay ~in (remap (~tri freq) 0 1)))

;; (def delayed-niegalo-sample
;;   (sum (map (fn (freq) (tri-delay niegalo-sample freq))
;;      '(0.01 0.02 0.04))))

;; (def cutoff (remap (~sin 0.01) 400 2000))
;; (def resonance 0.75)

;; (def filtered-sample (~lores (ugen niegalo-sample) cutoff resonance))

;; ;; (mrat.core.io.out [0])
;; (mrat.core.io.out (~mixer
;;                    1       filtered-sample
;;                    1       (~lores delayed-niegalo-sample cutoff resonance)
;;                    1       (~freeverb filtered-sample)
;;                    0.02    (~lores (~noise) 600 0.5)
;;                    0.25    (let ((phase-in (~phasor 0.001)))
;;                              (* phase-in (~lores (sum (map ~pulse '(30 60 120)))
;;                                           (+ (* 400 phase-in) 100)
;;                                           0)))
;;                    ))

;; (def bpm 120)

;; (def aeolian [0 2 3 5 7 9 11])
;; (def ionian [0 2 4 5 7 9 11])
;; (def dorian [0 2 3 5 7 9 10])
;; (def phrygian [0 1 3 5 7 8 10])
;; (def lydian [0 2 4 6 7 9 11])
;; (def mixolydian [0 2 4 5 7 9 10])
;; (def locrian [0 1 3 5 6 8 10])

;; (def (mode root intervals) (map (fn (x) (* root (semitones x))) intervals))

;; (def root B2)

;; (def (rotate n seq)
;;   (let ((vec (apply vector seq)))
;;     (concat (subvec vec n (length vec))
;;             (subvec vec 0 n))))

;; (def (rand-rng beg end)
;;   (+ beg (floor (* (rand) (- end beg)))))

;; (def seq (let ((notes (rotate (rand-rng 0 8) (conj aeolian 12))))
;;              (concat [] (mode root notes))))

;; (def triad (map (fn (w) (repeat (* 0.2 sample-rate) [w])) seq))
;; (def arpeggio (apply concat triad))
;; (def freqs (apply concat (repeat 100 [arpeggio])))

;; (def (~sin-inst w gate)
;;   (let ((~sig (~sin (* w (remap (~sin 2.4) (pow (cents 20) -1) (cents 20))) :duty (remap (~sin 10) 0.3 0.6)))
;;         (~env (~env gate '(0 1 1 0) '(0.01 0.1 0.05))))
;;     (* ~sig ~env)))

;; (def dry-sig (+ ;;(* 0.8 (~env (~pulse 2) '(0 1 1 0) '(0.01 0.2 0.1)) (~sin root :duty 0.7))
;;                 (* 0.4 (~sin-inst (ugen freqs) (~pulse 5)))))

;; (def hi-hat (let ((~sig (~noise)))
;;               (* (~env (~pulse 2) '(0 1 1 0) '(0.01 0.1 0.05)) (~lores ~sig 20000 0))))

;; (def bass (let ((~sig (~pulse 100)))
;;               (* (~env (~pulse 1) '(0 1 1 0) '(0.01 0.1 0.05)) ~sig)))

(mrat.core.io.out (~mixer 1 (~lores (~noise) (remap (~sin 0.1) 400 700) 0.6)))

