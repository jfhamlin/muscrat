package freeverb

import (
	"bufio"
	"math"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"testing"
)

func TestProcessReplace(t *testing.T) {
	type testCase struct {
		name string
		in   []float32
		out  []float32
	}

	cases := []testCase{}

	// Gold .out files are generated by the original C++ code.
	paths, err := filepath.Glob("testdata/*.in")
	if err != nil {
		t.Fatal(err)
	}
	for _, path := range paths {
		name := strings.TrimSuffix(filepath.Base(path), ".in")
		in, err := readFloats(path)
		if err != nil {
			t.Fatal(err)
		}
		out, err := readFloats("testdata/" + name + ".out")
		if err != nil {
			t.Fatal(err)
		}
		cases = append(cases, testCase{name: name, in: in, out: out})
	}

	for _, tc := range cases {
		tc := tc
		t.Run(tc.name, func(t *testing.T) {
			checkOutput(t, tc.in, tc.out)
		})
	}
}

func readFloats(path string) ([]float32, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	var floats []float32
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		f, err := strconv.ParseFloat(scanner.Text(), 32)
		if err != nil {
			return nil, err
		}
		floats = append(floats, float32(f))
	}
	return floats, nil
}

func checkOutput(t *testing.T, input []float32, expected []float32) {
	const allowedError = 0.0001

	outputL := make([]float32, len(input))
	outputR := make([]float32, len(input))

	rev := NewRevModel()

	// warm it up
	rev.ProcessReplace(input, input, outputL, outputR, len(input), 1)

	// second time should produce some reverb
	rev.ProcessReplace(input, input, outputL, outputR, len(input), 1)
	for i := range outputL {
		sum := outputL[i] + outputR[i]
		if math.Abs(float64(sum-expected[i])) > allowedError {
			t.Errorf("output[%d] = %f, expected %f", i, sum, expected[i])
		}
	}
}
