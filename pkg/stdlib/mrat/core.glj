(ns mrat.core
  (:import (github.com$jfhamlin$muscrat$pkg$graph Node
                                                  WithLabel)
           (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum
                                                 NewProduct)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Generator
                                                    WithDefaultDutyCycle
                                                    WithMultiply
                                                    WithAdd
                                                    Sin
                                                    Saw
                                                    Tri
                                                    Pulse
                                                    Phasor)
           (github.com$jfhamlin$muscrat$pkg$stochastic NewNoise
                                                       NewPinkNoise)
           (github.com$jfhamlin$muscrat$pkg$mod NewEnvelope)
           (github.com$jfhamlin$muscrat$pkg$effects NewFreeverb
                                                    NewLowpassFilter)
           (github.com/jfhamlin/freeverb-go NewRevModel)))

(def ^:dynamic *graph* nil)

(defn- add-node
  [ug label]
  (.AddGeneratorNode *graph* ug (WithLabel (str label))))

(defn- add-edge
  [x y port] (.AddEdge *graph* (.ID x) (.ID y) port))

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(extend-protocol AsNode
  Node
  (as-node [n] n))

(extend-protocol AsNode
  float64
  (as-node [x] (add-node (NewConstant x) x)))

(extend-protocol AsNode
  int64
  (as-node [x] (add-node (NewConstant x) x)))

(defn play
  [& channels]
  (let [num-sinks (count (. *graph* sinks))
        ch-inds (map vector channels (range (count channels)))]
    (doseq [ch-ind ch-inds]
      (let [ch (first ch-ind)
            i (second ch-ind)
            gen (as-node ch)
            chan-id (+ num-sinks i)
            sink (.AddSinkNode *graph* (WithLabel (fmt.Sprintf "out%d" chan-id)))]
        (add-edge gen sink "w"))))) ;; TODO: "w" seems wrong

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

(defn- +-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-sum (apply glojure.core/+ nums)]
    (if (empty? ugens)
      num-sum
      (let [sum-node (add-node (NewSum) "+")
            nodes (if (zero? num-sum) ugens
                      (conj ugens (add-node (NewConstant num-sum) num-sum)))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge n sum-node (str \$ i)))
        sum-node))))

(defn +
  "Return the sum of any combination of numbers or ugens.
  If any argument to + is a node, then the result of + is a node"
  ([] 0)
  ([x] x)
  ([x & more] (apply +-internal (cons x more))))

(defn- *-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-prod (apply glojure.core/* nums)]
    (if (empty? ugens)
      num-prod
      (let [prod-node (add-node (NewProduct) "*")
            nodes (conj ugens (add-node (NewConstant num-prod) num-prod))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge n prod-node (str \$ i)))
        prod-node))))

(defn *
  "Return the product of any combination of numbers or ugens.
  If any argument to * is a node, then the result of * is a node."
  ([] 0)
  ([x] x)
  ([x & more] (apply *-internal (cons x more))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(def default-freq 440)

(defn- handle-extra-gen-args
  [node args-map]
  (doseq [[k v] args-map]
    (let [gen (as-node v)
          param (k {:iphase "iphase"
                    :phase "phase"
                    :sync "sync"
                    :duty "dc"})]
      (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
      (add-edge gen node param))))

(defmacro defwtosc
  [name wavtab]
  (let [fn-name (symbol (str name))]
  `(defn ~fn-name
     ([] (~fn-name default-freq))
     ([freq# & args#]
      (if (odd? (count args#))
        (throw (fmt.Errorf "%s: odd number of flag args: %v" (str '~fn-name) args#)))
      (let [args# (into {} (partition 2 args#))
            gen# (~'Generator (~wavtab 1024))
            label# (~'WithLabel ~(str name))
            osc-node# (add-node gen# label#)
            freq-node# (as-node freq#)]
        (add-edge freq-node# osc-node# "w")
        (handle-extra-gen-args osc-node# args#)
        osc-node#)))))

(defwtosc sin Sin)
(defwtosc saw Saw)
(defwtosc tri Tri)
(defwtosc phasor Phasor)
;; (defwtosc sqr Pulse) ;; TODO: add default duty cycle and label support

;; (defn phasor
;;   ([] (phasor default-freq))
;;   ([freq & args]
;;    (let [freq-node (as-node freq)
;;          node (add-node (Generator (Phasor 1024)) "phasor")]
;;      (add-edge freq-node node "w")
;;      node)))

;; (def *sqr mrat.osc/sqr)
;; (def *pulse mrat.osc/pulse)
;; (def *sampler mrat.osc/sampler)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Noise

(defn noise
  []
  (add-node (NewNoise) "noise"))

(defn pink-noise
  []
  (add-node (NewPinkNoise) "pink-noise"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modulators

(defn env
  [gate levels times & opts]
  (let []))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Effects

(defn- freeverb-gen
  [& opts]
  (let [opts (apply hash-map opts)
        supported #{:dry :wet :room-size :damp :width}
        unsupported (seq (remove supported (keys opts)))
        dry (get opts :dry 0.5)
        wet (get opts :wet 0.5)
        room-size (get opts :room-size 0.5)
        damp (get opts :damp 0.5)
        width (get opts :width 1.0)]
    (if unsupported (throw (apply str "freeverb: unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (NewFreeverb
     (doto (NewRevModel)
       (.SetDry dry)
       (.SetWet wet)
       (.SetRoomSize room-size)
       (.SetDamp damp)
       (.SetWidth width)))))

(defn freeverb
  [node & opts]
  (let [fv-node (add-node (apply freeverb-gen opts) "freeverb")]
    (add-edge node fv-node "$0")
    fv-node))

(defn lores
  [n cutoff res]
  (let [n (as-node n)
        cutoff (as-node cutoff)
        res (as-node res)
        lpf (add-node (NewLowpassFilter) "lores")]
    (add-edge n lpf "in")
    (add-edge cutoff lpf "cutoff")
    (add-edge res lpf "resonance")
    lpf))

;; (def *delay mrat.effects/delay)
;; (def *clip mrat.effects/clip)
;; (def *trand mrat.math.rand/trand)
;; (def *env mrat.effects/env)

;; (def rand mrat.math.rand/rand)

;; (defn remap
;;   "Remap a value from [min-in, max-in] to [min-out, max-out].
;;   If not provided, [min-in, max-in] defaults to [-1, 1]"
;;   ([x min max] (remap x -1 1 min max)
;;   ([x min-in max-in min max]
;;    (let [range-in (- max-in min-in)
;;          range-out (- max min)
;;          x (- x min-in)]
;;      (+ min (/ (* x range-out) range-in)))))

;; (defn decibels [db] (pow 10 (/ db 20)))

;; (def *mixer
;;   (fn [& args]
;;     (let ((mixerArgs args))
;;       (let ((weightSum (reduce + 0
;;                                (map-idx (fn [val idx] (if (even? idx) val 0)) mixerArgs))))
;;         (sum (map (fn [idx] (let ((weight (nth mixerArgs (* 2 idx)))
;;                                   (chan   (nth mixerArgs (+ (* 2 idx) 1))))
;;                               (* (/ weight weightSum) chan)))
;;                   (range 0 (/ (length mixerArgs) 2))))))))

;; ;;; TODO: move to a library for music theory.
;; (defn cents [x] (pow 2 (/ x 1200)))
;; (defn semitones [x] (pow 2 (/ x 12)))
;; (defn octaves [x] (pow 2 x))
