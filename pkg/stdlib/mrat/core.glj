(ns mrat.core
  (:import (github.com$glojurelang$glojure$pkg$lang *Ratio *BigInt)
           (github.com$jfhamlin$muscrat$pkg$graph Node
                                                  WithLabel
                                                  WithSink)
           (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum
                                                 NewProduct
                                                 NewQuotient
                                                 NewAbs
                                                 NewExp
                                                 NewPow
                                                 NewCopySign
                                                 NewFreqRatio
                                                 NewMIDIFreq
                                                 NewImpulse
                                                 SimpleUGenFunc
                                                 WithInterp
                                                 InterpNone
                                                 InterpLinear
                                                 InterpCubic)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Generator
                                                    Table
                                                    WithDefaultDutyCycle
                                                    WithMultiply
                                                    WithAdd
                                                    Sin
                                                    Saw
                                                    Tri
                                                    Pulse
                                                    Phasor)
           (github.com$jfhamlin$muscrat$pkg$stochastic NewNoise
                                                       NewNoiseQuad
                                                       NewPinkNoise)
           (github.com$jfhamlin$muscrat$pkg$mod NewEnvelope
                                                WithReleaseNode
                                                WithInterpolation)
           (github.com$jfhamlin$muscrat$pkg$effects NewFreeverb
                                                    NewLowpassFilter
                                                    NewBPF
                                                    NewDelay
                                                    NewTapeDelay
                                                    NewWaveFolder
                                                    NewClip)
           (github.com$jfhamlin$muscrat$pkg$sampler NewSampler
                                                    LoadSample)
           (github.com$jfhamlin$muscrat$pkg$aio NewInputDevice
                                                NewQwertyMIDI
                                                NewMIDIInputDevice
                                                WithVoices
                                                WithDeviceID
                                                WithDeviceName
                                                WithChannel
                                                WithController
                                                WithDefaultValue
                                                NewWavOut)
           (github.com$jfhamlin$freeverb-go NewRevModel)))

(def ^:dynamic *graph* nil)

(defmacro doseq-idx
  [[locals seq-expr] & body]
  `(let [s# ~seq-expr]
     (doseq [~locals (map vector s# (range (count s#)))]
       ~@body)))

(defn add-node!
  [ug label & {:keys [sink]}]
  (if sink
    (.AddGeneratorNode *graph* ug (WithLabel (str label)) (WithSink))
    (.AddGeneratorNode *graph* ug (WithLabel (str label)))))

(defn add-edge!
  [x y port] (.AddEdge *graph* (.ID x) (.ID y) port))

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(extend-protocol AsNode
  Node
  (as-node [n] n))

(extend-protocol AsNode
  go/float64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  go/int64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  *BigInt
  (as-node [x] (add-node! (NewConstant (double x)) x)))

(extend-protocol AsNode
  *Ratio
  (as-node [x] (add-node! (NewConstant (double x)) x)))

(defn play
  [channels]
  (let [channels (if-not (coll? channels) [channels channels] channels)
        channels (if (= (count channels) 0) [0 0] channels)
        channels (if (= (count channels) 1) [(first channels) (first channels)] channels)
        num-sinks (count (. *graph* outputs))
        ch-inds (map vector channels (range (count channels)))]
    (doseq [[ch i] ch-inds]
      (let [gen (as-node ch)
            chan-id (+ num-sinks i)
            sink (.AddOutNode *graph* (WithLabel (fmt.Sprintf "out%d" chan-id)))]
        (add-edge! gen sink "w"))))) ;; TODO: "w" seems wrong

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

(defn pow
  [b e]
  (if (some (partial instance? Node) [b e])
    (let [n (add-node! (NewPow) "pow")]
      (add-edge! (as-node b) n "base")
      (add-edge! (as-node e) n "exp")
      n)
    (math.Pow b e)))

(defn abs
  [x]
  (if (instance? Node x)
    (let [n (add-node! (NewAbs) "abs")]
      (add-edge! x n "in")
      n)
    (math.Abs x)))

(defn exp
  [x]
  (if (instance? Node x)
    (let [n (add-node! (NewExp) "exp")]
      (add-edge! x n "in")
      n)
    (math.Exp x)))

(defn copy-sign
  [x s]
  (if (or (instance? Node x) (instance? Node s))
    (let [n (add-node! (NewCopySign) "copy-sign")]
      (add-edge! (as-node x) n "in")
      (add-edge! (as-node s) n "sign")
      n)
    (math.Copysign x s)))

(defn- freq-ratio
  [x kind]
  (let [n (add-node! (NewFreqRatio kind) kind)]
    (add-edge! x n "in")
    n))

(defn decibels
  [db]
  (if (instance? Node db)
    (freq-ratio db "decibels")
    (pow 10 (/ db 20.0))))

(defn cents
  [x]
  (if (instance? Node x)
    (let [cnt (add-node! (NewFreqRatio "cents") "cents")]
      (add-edge! x cnt "in")
      cnt)
    (pow 2 (/ x 1200.0))))

(defn semitones
  [x]
  (if (instance? Node x)
    (let [stn (add-node! (NewFreqRatio "semitones") "semitones")]
      (add-edge! x stn "in")
      stn)
    (pow 2 (/ x 12.0))))

(defn octaves
  [x]
  (if (instance? Node x)
    (let [oct (add-node! (NewFreqRatio "octaves") "octaves")]
      (add-edge! x oct "in")
      oct)
    (pow 2 x)))

(defn midifreq
  [note]
  (if (instance? Node note)
    (let [mf (add-node! (NewMIDIFreq) "midifreq")]
      (add-edge! note mf "in")
      mf)
    (* 440.0 (pow 2 (/ (- note 69.0) 12.0)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper for custom sample generators

(defn ugen-fn
  [f]
  (let [wrapped (fn [cfg out]
                  (f {:sample-rate-hz (.SampleRateHz cfg)
                      :input-samples (.InputSamples cfg)}
                     out))]
    (SimpleUGenFunc wrapped)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

(defn- +-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-sum (apply glojure.core/+ nums)]
    (if (empty? ugens)
      num-sum
      (let [sum-node (add-node! (NewSum) "+")
            nodes (if (zero? num-sum)
                    ugens
                    (conj ugens (add-node! (NewConstant num-sum) num-sum)))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n sum-node (str \$ i)))
        sum-node))))

(defn +
  "Return the sum of any combination of numbers or ugens.
  If any argument to + is a node, then the result of + is a node.  If
  any argument to + is a collection, then the result is a collection
  whose length is the length of the longest collection (max-len) and
  where the elements of each argument are added pairwise. Any
  non-collections are duplicated to max-len, and any collections
  shorter than max-len are cycled up to max-len."
  ([] 0)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map + colls))
       (apply +-internal args)))))

(defn -
  "Return the difference of any combination of numbers or ugens.
  If any argument to - is a node, then the result of - is a node"
  ([] 0)
  ([x] (* -1 x))
  ([x & more] (+ x (apply + (map #(* -1 %) more)))))

(defn- *-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-prod (apply glojure.core/* nums)]
    (if (empty? ugens)
      num-prod
      (let [prod-node (add-node! (NewProduct) "*")
            nodes (conj ugens (add-node! (NewConstant (double num-prod)) num-prod))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n prod-node (str \$ i)))
        prod-node))))

(defn *
  "Return the product of any combination of numbers or ugens.
  If any argument to * is a node, then the result of * is a node."
  ([] 1)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map * colls))
       (apply *-internal args)))))

(defn- div-internal
  [& xs]
  (if (every? #(not (instance? Node %)) xs)
    (apply glojure.core// xs)
    (let [quot-node (add-node! (NewQuotient) "/")
          nodes (map as-node xs)]
      (doseq [[n i] (map vector nodes (range (count nodes)))]
        (add-edge! n quot-node (str \$ i)))
      quot-node)))

(defn /
  "Return the quotient of any combination of numbers or ugens.
  If any argument to / is a node, then the result of / is a node."
  ([x] (/ 1 x))
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map / colls))
       (apply div-internal args)))))

(defn sum
  [coll] (apply + coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(def default-freq 440)

(defn- validate-flags
  [flags defaults]
  (if (odd? (count flags))
    (throw (apply str "odd number of flag args: " (interpose \, flags))))
  (let [m (reduce #(apply assoc %1 %2) {} (partition 2 flags))
        unsupported (seq (remove (set (keys defaults)) (keys m)))]
    (if unsupported (throw (apply str "unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (merge defaults m)))

(defn- handle-extra-gen-args
  [node args-map]
  (doseq [[k v] args-map]
    (let [gen (as-node v)
          param (k {:iphase "iphase"
                    :phase "phase"
                    :sync "sync"
                    :duty "dc"})]
      (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
      (add-edge! gen node param))))

(defmacro defwtosc
  [name wavtab & default-args]
  (let [fn-name (symbol (str name))
        default-args (vec default-args)]
    `(defn ~fn-name
       ([] (~fn-name default-freq))
       ([freq# & args#]
        (if (keyword? freq#)
          (apply ~fn-name default-freq freq# args#)
          (do
            (if (odd? (count args#))
              (throw (fmt.Errorf "%s: odd number of flag args: %v" (str ~name) args#)))
            (let [args# (if (empty? ~default-args) args# (concat ~default-args args#))
                  args# (reduce #(apply assoc %1 %2) {} (partition 2 args#))
                  wt-opts# [(~'WithDefaultDutyCycle (get args# :default-duty 1))
                            (~'WithMultiply (get args# :mul 1.0))
                            (~'WithAdd (get args# :add 0.0))]
                  args# (dissoc args# :default-duty :mul :add)
                  gen# (apply ~'Generator (~wavtab 1024) wt-opts#)
                  label# (~'WithLabel ~(str name))
                  osc-node# (add-node! gen# label#)
                  freq-node# (as-node freq#)]
              (add-edge! freq-node# osc-node# "w")
              (handle-extra-gen-args osc-node# args#)
              osc-node#)))))))

(defwtosc sin Sin)
(defwtosc saw Saw)
(defwtosc tri Tri)
(defwtosc phasor Phasor)
(defwtosc pulse Pulse :default-duty 0.5)
(defwtosc sqr Pulse :default-duty 0.5)

(defn impulse
  [freq & flags]
  (let [flags (validate-flags flags {:iphase 0})
        iphase (:iphase flags)
        iphase (if iphase (as-node iphase))
        freq-node (as-node freq)
        node (add-node! (NewImpulse) (WithLabel "impulse"))]
    (if iphase (add-edge! iphase node "iphase"))
    (add-edge! freq-node node "w")
    node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Noise

;; todo: add/mul flags

(defn noise
  "Generates random values between -1 and 1 at the given frequency.
  If frequency is zero or not provided, generates white noise. Currently,
  frequency must be a number, not a node."
  ([] (noise 0))
  ([freq & flags]
   (let [flags (validate-flags flags {:mul 1.0 :add 0.0})
         opts [(github.com$jfhamlin$muscrat$pkg$ugen.WithMul (:mul flags))
               (github.com$jfhamlin$muscrat$pkg$ugen.WithAdd (:add flags))]
         n (add-node! (apply NewNoise opts) "noise")
         f (as-node freq)]
     (add-edge! f n "w")
     n)))

(defn pink-noise
  []
  (add-node! (NewPinkNoise) "pink-noise"))

(defn noise-quad
  "Generates quadratically-interpolated random values between
  -1 and 1 at the given frequency. If frequency is zero or not
  provided, generates at 500 hz."
  ([] (noise-quad 500.0))
  ([freq & flags]
   (let [flags (validate-flags flags {:mul 1.0 :add 0.0})
         opts [(github.com$jfhamlin$muscrat$pkg$ugen.WithMul (:mul flags))
               (github.com$jfhamlin$muscrat$pkg$ugen.WithAdd (:add flags))]
         n (add-node! (apply NewNoiseQuad opts) "noise-quad")
         f (as-node freq)]
     (add-edge! f n "w")
     n)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modulators

(defn env
  [gate levels times & flags]
  (let [flags (validate-flags flags {:interp :lin, :release-node -1})
        trigger (as-node gate)
        levels (map as-node levels)
        times (map as-node times)]
    (if (not= (count levels) (inc (count times)))
      (throw (str "env expects the number of levels to be one more than the number of times, got " (count levels) " levels and " (count times) " times.")))
    (let [env-node (add-node! (NewEnvelope
                               (WithInterpolation (subs (str (:interp flags)) 1))
                               (WithReleaseNode (:release-node flags)))
                              "envelope")]
      (add-edge! trigger env-node "trigger")
      (doseq [[n i] (map vector levels (range (count levels)))]
        (add-edge! n env-node (str "level$" i)))
      (doseq [[n i] (map vector times (range (count times)))]
        (add-edge! n env-node (str "time$" i)))
      env-node)))

(defn env-asr
  [gate [a s r]]
  (env gate [0 s 0] [a r] :release-node 1))

(defn env-adsr
  [gate [a d s r]]
  (env gate [0 1 s 0] [a d r] :release-node 2))

(defn env-perc
  [gate [a d]]
  (env gate [0 1 0] [a d]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Effects

(defn pipe
  []
  (let [f (fn [cfg out]
            (when-let [in (get (:input-samples cfg) "in")]
              (go/copy out in)))]
    (add-node! (ugen-fn f) "pipe")))

(defn pipeset!
  [p in]
  (add-edge! (as-node in) p "in"))

(defn- freeverb-gen
  [& opts]
  (let [wet (get opts :wet 0.5)
        damp (get opts :damp 0.5)
        width (get opts :width 1.0)]
    (NewFreeverb
     (doto (NewRevModel)
       (.SetWet wet)
       (.SetDamp damp)
       (.SetWidth width)))))

(defn freeverb
  [node & opts]
  (let [opts (apply hash-map opts)
        supported #{:dry :wet :room-size :damp :width}
        unsupported (seq (remove supported (keys opts)))
        _ (if unsupported (throw (apply str "freeverb: unsupported option(s) supplied: "
                                        (interpose \, unsupported))))
        fv-node (add-node! (apply freeverb-gen opts) "freeverb")
        rs-node (as-node (get opts :room-size 0.5))
        dry-node (as-node (get opts :dry 0.5))]
    (add-edge! node fv-node "$0")
    (add-edge! rs-node fv-node "room-size")
    (add-edge! dry-node fv-node "dry")
    fv-node))

(defn lores
  "A simple lowpass filter with cutoff and resonance."
  [n cutoff res]
  (let [n (as-node n)
        cutoff (as-node cutoff)
        res (as-node res)
        lpf (add-node! (NewLowpassFilter) "lores")]
    (add-edge! n lpf "in")
    (add-edge! cutoff lpf "cutoff")
    (add-edge! res lpf "resonance")
    lpf))

(defn bpf
  [n freq bw]
  (let [n (as-node n)
        freq (as-node freq)
        bw (as-node bw)
        filter (add-node! (NewBPF) "bpf")]
    (add-edge! n filter "in")
    (add-edge! freq filter "w")
    (add-edge! bw filter "bw")
    filter))

(defn- -delay
  [in max-delay-time delay-time interp-opt & flags]
  (let [flags (validate-flags flags {:mul 1.0 :add 0.0})
        opts [(github.com$jfhamlin$muscrat$pkg$ugen.WithMul (:mul flags))
              (github.com$jfhamlin$muscrat$pkg$ugen.WithAdd (:add flags))]
        delay (add-node! (apply NewDelay max-delay-time interp-opt opts) "delay")]
    (add-edge! (as-node in) delay "in")
    (add-edge! (as-node delay-time) delay "delay")
    delay))

(defn delayn
  [in max-delay-time delay-time & flags]
  (apply -delay in max-delay-time delay-time (WithInterp InterpNone) flags))

(defn delayl
  [in max-delay-time delay-time & flags]
  (apply -delay in max-delay-time delay-time (WithInterp InterpLinear) flags))

(defn delayc
  [in max-delay-time delay-time & flags]
  (apply -delay in max-delay-time delay-time (WithInterp InterpCubic) flags))

(defn tape-delayl
  "Tape delay line with linear interpolation. This generator simulates a
  tape read head such that changes to the delay value are not
  instantaneous - the 'tape' is sped up or slowed down to reach the
  target delay time."
  [n delay-time]
  (let [delay (add-node! (NewTapeDelay) "tape-delay")]
    (add-edge! (as-node n) delay "$0")
    (add-edge! (as-node delay-time) delay "delay")
    delay))

(defn- comb-feedback
  [delay-time decay-time]
  (if (or (and (not (instance? Node delay-time)) (zero? delay-time))
          (and (not (instance? Node decay-time)) (zero? decay-time)))
    0.0
    (let [abs-decay (abs decay-time)
          power (/ (* (math.Log 0.001) delay-time) abs-decay)
          absret (exp power)]
      (copy-sign absret decay-time))))

(defn- -comb
  [in max-delay-time delay-time decay-time delay-fn & flags]
  (let [flags (validate-flags flags {:mul 1.0 :add 0.0})
        opts [(github.com$jfhamlin$muscrat$pkg$ugen.WithMul (:mul flags))
              (github.com$jfhamlin$muscrat$pkg$ugen.WithAdd (:add flags))]
        feedback (pipe)
        delay (delay-fn feedback max-delay-time delay-time)
        fb-coefficient (comb-feedback delay-time decay-time)
        comb (+ in (* fb-coefficient delay))]
    (pipeset! feedback comb)
    comb))

(defn combn
  [in max-delay-time delay-time decay-time & flags]
  (apply -comb in max-delay-time delay-time decay-time delayn flags))

(defn combl
  [in max-delay-time delay-time decay-time & flags]
  (apply -comb in max-delay-time delay-time decay-time delayl flags))

(defn combc
  [in max-delay-time delay-time decay-time & flags]
  (apply -comb in max-delay-time delay-time decay-time delayc flags))

(defn pan2
  ([in pos] (pan2 in pos 1))
  ([in pos level]
   (let [pos (as-node pos)
         mid (as-node 0.707)
         sq (* -0.207 pos pos)
         left-scale (+ mid (* -0.5 pos) sq)
         right-scale (+ mid (* 0.5 pos) sq)]
     [(* level left-scale in)
      (* level right-scale in)])))

(defn clip
  ([in] (clip in -1 1))
  ([in lo hi]
   (let [c (add-node! (NewClip) "clip")
         [in lo hi] (map as-node [in lo hi])]
     (add-edge! in c "in")
     (add-edge! lo c "lo")
     (add-edge! hi c "hi")
     c)))

(defn wfold
  "Fold an input signal when it exceeds threshold low/high values.
  The signal is reflected across the low and high threshold values.
  Default low and high are -1 and 1."
  ([in] (wfold in -1 1))
  ([in lo hi]
   (let [wf (add-node! (NewWaveFolder) "wfold")
         [in lo hi] (map as-node [in lo hi])]
     (add-edge! in wf "in")
     (add-edge! lo wf "lo")
     (add-edge! hi wf "hi")
     wf)))

(defn bitcrusher
  ([in bits] (bitcrusher in bits 44100.0))
  ([in bits rate]
   (let [rate (as-node rate)
         bits (as-node bits)
         out (add-node! (github.com$jfhamlin$muscrat$pkg$effects.NewBitcrusher) "bitcrusher")]
     (add-edge! in out "in")
     (add-edge! rate out "rate")
     (add-edge! bits out "bits")
     out)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sampler

(defn load-sample
  [path] (LoadSample path))

(defn sampler
  ([sample & flags]
   (let [[gate flags] (if-not (keyword? (first flags))
                        [(first flags) (rest flags)]
                        [nil flags])
         [rate flags] (if-not (keyword? (first flags))
                        [(first flags) (rest flags)]
                        [nil flags])
         flags (validate-flags flags {:loop false})
         node (add-node! (NewSampler (seq sample) (:loop flags)) "sampler")]
     (if gate
       (add-edge! (as-node gate) node "trigger"))
     (if (and rate (not= rate 1.0))
       (add-edge! (as-node rate) node "rate"))
     node)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; I/O devices

(defn soundin
  []
  (add-node! (NewInputDevice) "in"))

(defn midi-in
  "Registers one or more input ugens that emit values from MIDI events.
  The 'name' argument is a user-defined name for the input, which is
  used to identify the input in the user interface. The 'typ' argument
  is the type of event to track, one of:

  - :note - returns a seq, one element per voice (see flags), of
     maps with elements for note on/off (1/0), midi note number, and
     velocity: {:onoff <node> :note <node> :velocity <node>}
  - :bend - returns a single ugen node for the pitch bend value
  - :cc - returns a single ugen node for a single controller change
    value.
  - :after-touch - returns a single ugen node for mono aftertouch

  # Voices

  The :note input type is monophonic by default, with a single set of
  ugens tracking the latest note. To enable polyphony, provide the
  number of voices with the :voices flag. Notes on the mapped channel
  will be automatically allocated across the returned voices.

  # Device Mappings

  Input ugens can be (re-)mapped in the user interface, but the
  default mapping can be controlled with the following flags:

  - :device-id - The MIDI device ID, or a seq of IDs. If a seq, the
    first matching device in the seq is used. Default is 0.
  - :device-name - A regular expression to match against the device
    name.
  - :channel - The channel to map to. Default is 0.
  - :controller - For :cc type, the controller ID to map to. Default
    is 0."
  [name typ & flags]
  (let [_ (if-not (contains? #{:note :bend :cc :after-touch} typ)
            (throw (fmt.Errorf "unsupported midi-in type: %s" typ)))
        flags (validate-flags flags {:voices 1
                                     :device-id 0
                                     :device-name nil
                                     :channel 0
                                     :controller 0
                                     :default 0})
        num-voices (:voices flags)
        opts [(WithVoices num-voices)
              (WithDeviceID (:device-id flags))
              (WithChannel (:channel flags))
              (WithController (:controller flags))
              (WithDefaultValue (:default flags))]
        opts (if-let [name (:device-name flags)]
               (conj opts (WithDeviceName name))
               opts)
        dev (apply NewMIDIInputDevice name opts)]
    (case typ
      :note     (map #(do {:note (add-node! (.Note dev %) "midi-note")
                           :onoff (add-node! (.Gate dev %) "midi-gate")})
                     (range num-voices))
      :cc (add-node! (.Control dev) "midi-cc")
      (throw (fmt.Errorf "unsupported midi-in type: %s" typ))
      )))

;; (defn midi-in
;;   [name & flags]
;;   (let [flags (validate-flags flags {:voices 1})
;;         num-voices (:voices flags)
;;         dev (NewMIDIInputDevice name "sw-keyboard" (WithVoices num-voices))]
;;     (map #(vector (add-node! (.Notes dev %) "midi-note")
;;                   (add-node! (.Gates dev %) "midi-gate"))
;;          (range num-voices))))

(defn wavout
  "Save the input to a 32-bit wav file (up to two channels) named by
  the :filename flag (default out.wav)."
  [chs & flags]
  (let [chs (if (coll? chs) chs [chs])
        flags (validate-flags flags {:filename "out.wav"})
        _ (if (> (count chs) 2) (throw (str "wavout: too many channels supplied: " (count chs))))
        ch0 (as-node (first chs))
        ch1 (second chs)
        n (add-node! (NewWavOut (:filename flags)) "wavout" :sink true)]
    (add-edge! ch0 n "$0")
    (when ch1
      (add-edge! ch1 n "$1"))
    n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pattern utilities

(defn clock-grid
  "Generates an impulse given beats per minute and a number of impulses
  per beat. The impulses are emitted evenly over the beat."
  [bpm res & flags]
  (let [bps (/ bpm 60.0)]
    (apply impulse (* bps res) flags)))

(defn sequencer
  [gate freqs]
  (let [node (add-node! (github.com$jfhamlin$muscrat$pkg$pattern.NewSequencer) "sequencer")
        gate (as-node gate)
        freqs (map as-node freqs)]
    (add-edge! gate node "trigger")
    (doseq-idx [[freq i] freqs]
               (add-edge! freq node (str \$ i)))
    node))

(defn trig-pattern
  [clock pattern]
  (let [s (sequencer clock pattern)]
    (* s clock)))

(defn choose
  [gate opts]
  (let [node (add-node! (github.com$jfhamlin$muscrat$pkg$pattern.NewChoose) "choose")
        gate (as-node gate)
        opts (map as-node opts)]
    (add-edge! gate node "trigger")
    (doseq-idx [[opt i] opts]
               (add-edge! opt node (str \$ i)))
    node))

(def choose-gate choose)
