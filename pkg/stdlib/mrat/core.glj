(ns mrat.core
  (:import (github.com$jfhamlin$muscrat$pkg$graph Node
                                                  WithLabel)
           (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum
                                                 NewProduct
                                                 NewFreqRatio
                                                 SimpleSampleGeneratorFunc)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Generator
                                                    Table
                                                    WithDefaultDutyCycle
                                                    WithMultiply
                                                    WithAdd
                                                    Sin
                                                    Saw
                                                    Tri
                                                    Pulse
                                                    Phasor)
           (github.com$jfhamlin$muscrat$pkg$stochastic NewNoise
                                                       NewNoiseQuad
                                                       NewPinkNoise)
           (github.com$jfhamlin$muscrat$pkg$mod NewEnvelope
                                                WithReleaseNode
                                                WithInterpolation)
           (github.com$jfhamlin$muscrat$pkg$effects NewFreeverb
                                                    NewLowpassFilter
                                                    NewBPF
                                                    NewDelay
                                                    NewWaveFolder)
           (github.com$jfhamlin$muscrat$pkg$sampler NewSampler
                                                    LoadSample)
           (github.com$jfhamlin$muscrat$pkg$aio NewInputDevice
                                                NewQwertyMIDI
                                                NewMIDIDevice
                                                WithVoices
                                                NewWavOut)
           (github.com$jfhamlin$freeverb-go NewRevModel)))

(def ^:dynamic *graph* nil)

(defn add-node!
  [ug label]
  (.AddGeneratorNode *graph* ug (WithLabel (str label))))

(defn add-edge!
  [x y port] (.AddEdge *graph* (.ID x) (.ID y) port))

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(extend-protocol AsNode
  Node
  (as-node [n] n))

(extend-protocol AsNode
  float64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  int64
  (as-node [x] (add-node! (NewConstant x) x)))

(defn play
  [channels]
  (let [channels (if-not (coll? channels) [channels channels] channels)
        channels (if (= (count channels) 0) [0 0] channels)
        channels (if (= (count channels) 1) [(first channels) (first channels)] channels)
        num-sinks (count (. *graph* sinks))
        ch-inds (map vector channels (range (count channels)))]
    (doseq [[ch i] ch-inds]
      (let [gen (as-node ch)
            chan-id (+ num-sinks i)
            sink (.AddSinkNode *graph* (WithLabel (fmt.Sprintf "out%d" chan-id)))]
        (add-edge! gen sink "w"))))) ;; TODO: "w" seems wrong

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

(defn pow
  [b e] (math.Pow b e)) ;; TODO: use glojure.math

(defn- freq-ratio
  [x kind]
  (let [n (add-node! (NewFreqRatio kind) kind)]
    (add-edge! x n "in")
    n))

(defn decibels
  [db]
  (if (instance? Node db)
    (freq-ratio db "decibels")
    (pow 10 (/ db 20.0))))

(defn cents [x] (pow 2 (/ x 1200.0)))

(defn semitones
  [x]
  (if (instance? Node x)
    (let [stn (add-node! (NewFreqRatio "semitones") "semitones")]
      (add-edge! x stn "in")
      stn)
    (pow 2 (/ x 12.0))))

(defn octaves [x] (pow 2 x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

(defn- +-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-sum (apply glojure.core/+ nums)]
    (if (empty? ugens)
      num-sum
      (let [sum-node (add-node! (NewSum) "+")
            nodes (if (zero? num-sum) ugens
                      (conj ugens (add-node! (NewConstant num-sum) num-sum)))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n sum-node (str \$ i)))
        sum-node))))

(defn +
  "Return the sum of any combination of numbers or ugens.
  If any argument to + is a node, then the result of + is a node.  If
  any argument to + is a collection, then the result is a collection
  whose length is the length of the longest collection (max-len) and
  where the elements of each argument are added pairwise. Any
  non-collections are duplicated to max-len, and any collections
  shorter than max-len are cycled up to max-len."
  ([] 0)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map + colls))
       (apply +-internal args)))))

(defn -
  "Return the difference of any combination of numbers or ugens.
  If any argument to - is a node, then the result of - is a node"
  ([] 0)
  ([x] (* -1 x))
  ([x & more] (+ x (apply + (map #(* -1 %) more)))))

(defn- *-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-prod (apply glojure.core/* nums)]
    (if (empty? ugens)
      num-prod
      (let [prod-node (add-node! (NewProduct) "*")
            nodes (conj ugens (add-node! (NewConstant num-prod) num-prod))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n prod-node (str \$ i)))
        prod-node))))

(defn *
  "Return the product of any combination of numbers or ugens.
  If any argument to * is a node, then the result of * is a node."
  ([] 1)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map * colls))
       (apply *-internal args)))))

(defn sum
  [coll] (apply + coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(def default-freq 440)

(defn- validate-flags
  [flags defaults]
  (if (odd? (count flags))
    (throw (apply str "odd number of flag args: " (interpose \, flags))))
  (let [m (reduce #(apply assoc %1 %2) {} (partition 2 flags))
        unsupported (seq (remove (set (keys defaults)) (keys m)))]
    (if unsupported (throw (apply str "unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (merge defaults m)))

(defn- handle-extra-gen-args
  [node args-map]
  (doseq [[k v] args-map]
    (let [gen (as-node v)
          param (k {:iphase "iphase"
                    :phase "phase"
                    :sync "sync"
                    :duty "dc"})]
      (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
      (add-edge! gen node param))))

(defmacro defwtosc
  [name wavtab & default-args]
  (let [fn-name (symbol (str name))
        default-args (vec default-args)]
    `(defn ~fn-name
       ([] (~fn-name default-freq))
       ([freq# & args#]
        (if (keyword? freq#)
          (apply ~fn-name default-freq freq# args#)
          (do
            (if (odd? (count args#))
              (throw (fmt.Errorf "%s: odd number of flag args: %v" (str ~name) args#)))
            (let [args# (if (empty? ~default-args) args# (concat ~default-args args#))
                  args# (reduce #(apply assoc %1 %2) {} (partition 2 args#))
                  wt-opts# [(~'WithDefaultDutyCycle (get args# :default-duty 1))
                            (~'WithMultiply (get args# :mul 1.0))
                            (~'WithAdd (get args# :add 0.0))]
                  args# (dissoc args# :default-duty :mul :add)
                  gen# (apply ~'Generator (~wavtab 1024) wt-opts#)
                  label# (~'WithLabel ~(str name))
                  osc-node# (add-node! gen# label#)
                  freq-node# (as-node freq#)]
              (add-edge! freq-node# osc-node# "w")
              (handle-extra-gen-args osc-node# args#)
              osc-node#)))))))

(defwtosc sin Sin)
(defwtosc saw Saw)
(defwtosc tri Tri)
(defwtosc phasor Phasor)
(defwtosc pulse Pulse :default-duty 0.5)
(defwtosc sqr Pulse :default-duty 0.5)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Noise

;; todo: add/mul flags

(defn noise
  "Generates random values between -1 and 1 at the given frequency.
  If frequency is zero or not provided, generates white noise. Currently,
  frequency must be a number, not a node."
  ([] (noise 0))
  ([freq]
   (let [n (add-node! (NewNoise) "noise")
         f (as-node freq)]
     (add-edge! f n "w")
     n)))

(defn pink-noise
  []
  (add-node! (NewPinkNoise) "pink-noise"))

(defn noise-quad
  "Generates quadratically-interpolated random values between
  -1 and 1 at the given frequency. If frequency is zero or not
  provided, generates at 500 hz."
  ([] (noise-quad 500.0))
  ([freq]
   (let [n (add-node! (NewNoiseQuad) "noise-quad")
         f (as-node freq)]
     (add-edge! f n "w")
     n)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modulators

(defn env
  [gate levels times & flags]
  (let [flags (validate-flags flags {:interp :lin, :release-node -1})
        trigger (as-node gate)
        levels (map as-node levels)
        times (map as-node times)]
    (if (not= (count levels) (inc (count times)))
      (throw (str "env expects the number of levels to be one more than the number of times, got " (count levels) " levels and " (count times) " times.")))
    (let [env-node (add-node! (NewEnvelope
                               (WithInterpolation (subs (str (:interp flags)) 1))
                               (WithReleaseNode (:release-node flags)))
                              "envelope")]
      (add-edge! trigger env-node "trigger")
      (doseq [[n i] (map vector levels (range (count levels)))]
        (add-edge! n env-node (str "level$" i)))
      (doseq [[n i] (map vector times (range (count times)))]
        (add-edge! n env-node (str "time$" i)))
      env-node)))

(defn env-asr
  [gate [a s r]]
  (env gate [0 s 0] [a r] :release-node 1))

(defn env-adsr
  [gate [a d s r]]
  (env gate [0 1 s 0] [a d r] :release-node 2))

(defn env-perc
  [gate [a d]]
  (env gate [0 1 0] [a d]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Effects

(defn- freeverb-gen
  [& opts]
  (let [wet (get opts :wet 0.5)
        damp (get opts :damp 0.5)
        width (get opts :width 1.0)]
    (NewFreeverb
     (doto (NewRevModel)
       (.SetWet wet)
       (.SetDamp damp)
       (.SetWidth width)))))

(defn freeverb
  [node & opts]
  (let [opts (apply hash-map opts)
        supported #{:dry :wet :room-size :damp :width}
        unsupported (seq (remove supported (keys opts)))
        _ (if unsupported (throw (apply str "freeverb: unsupported option(s) supplied: "
                                        (interpose \, unsupported))))
        fv-node (add-node! (apply freeverb-gen opts) "freeverb")
        rs-node (as-node (get opts :room-size 0.5))
        dry-node (as-node (get opts :dry 0.5))]
    (add-edge! node fv-node "$0")
    (add-edge! rs-node fv-node "room-size")
    (add-edge! dry-node fv-node "dry")
    fv-node))

(defn lores
  "A simple lowpass filter with cutoff and resonance."
  [n cutoff res]
  (let [n (as-node n)
        cutoff (as-node cutoff)
        res (as-node res)
        lpf (add-node! (NewLowpassFilter) "lores")]
    (add-edge! n lpf "in")
    (add-edge! cutoff lpf "cutoff")
    (add-edge! res lpf "resonance")
    lpf))

(defn bpf
  [n freq bw]
  (let [n (as-node n)
        freq (as-node freq)
        bw (as-node bw)
        filter (add-node! (NewBPF) "bpf")]
    (add-edge! n filter "in")
    (add-edge! freq filter "w")
    (add-edge! bw filter "bw")
    filter))

(defn delayl
  "Delay line with linear interpolation."
  [n delay-time]
  (let [delay (add-node! (NewDelay) "delay")]
    (add-edge! (as-node n) delay "$0")
    (add-edge! (as-node delay-time) delay "delay")
    delay))

(defn pan2
  ([in pos] (pan2 in pos 1))
  ([in pos level]
   (let [pos (as-node pos)
         mid (as-node 0.707)
         sq (* -0.207 pos pos)
         left-scale (+ mid (* -0.5 pos) sq)
         right-scale (+ mid (* 0.5 pos) sq)]
     [(* level left-scale in)
      (* level right-scale in)])))

(defn wfold
  "Fold an input signal when it exceeds threshold low/high values.
  The signal is reflected across the low and high threshold values.
  Default low and high are -1 and 1."
  ([in] (wfold in -1 1))
  ([in lo hi]
   (let [wf (add-node! (NewWaveFolder) "wfold")
         in (as-node in)
         lo (as-node lo)
         hi (as-node hi)]
     (add-edge! in wf "in")
     (add-edge! lo wf "lo")
     (add-edge! hi wf "hi")
     wf)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sampler

(defn load-sample
  [path] (LoadSample path))

(defn sampler
  ([sample & flags]
   (let [flags (validate-flags flags {:loop true})
         node (add-node! (NewSampler (seq sample) (:loop flags)) "sampler")]
     node)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; I/O devices

(defn soundin
  []
  (add-node! (NewInputDevice) "in"))

(defn qwerty-midi
  []
  (let [midi (NewQwertyMIDI)
        trig (.AsTrigger midi)]
    [(add-node! midi "qwerty-midi")
     (add-node! trig "qwerty-trig")]))

(defn midi-in
  [name & flags]
  (let [flags (validate-flags flags {:voices 1})
        num-voices (:voices flags)
        dev (NewMIDIDevice name "sw-keyboard" (WithVoices num-voices))]
    (map #(vector (add-node! (.Notes dev %) "midi-note")
                  (add-node! (.Gates dev %) "midi-gate"))
         (range num-voices))))

    ;; {:notes (map #(add-node! (.Notes dev %) "midi-note") (range num-voices))
    ;;  :gates (map #(add-node! (.Gates dev %) "midi-gate") (range num-voices))
    ;;  }))

(defn wavout
  "Save the input to a 32-bit wav file (up to two channels) named by
  the :filename flag (default out.wav)."
  [ch & ch-flags]
  (let [[chs flags] (split-with #(not (keyword? %)) ch-flags)
        flags (validate-flags flags {:filename "out.wav"})
        _ (if (> (count chs) 1) (throw (str "wavout: too many channels supplied: " (count chs))))
        ch0 (as-node ch)
        ch1 (first chs)
        n (add-node! (NewWavOut (:filename flags)) "wavout")]
    (add-edge! ch0 n "$0")
    (when ch1
      (add-edge! ch1 n "$1"))
    n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Custom sample generators

(defn ugen-fn
  [f]
  (let [wrapped (fn [cfg n]
                  (f {:sample-rate-hz (.SampleRateHz cfg)
                      :input-samples (.InputSamples cfg)}
                     n))]
    (SimpleSampleGeneratorFunc wrapped)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pattern utilities

(defn sequencer
  [notes times & flags]
  (let [flags (validate-flags flags {:loop true})
        looping (:loop flags)
        counter (atom nil)
        index (atom 0)
        done (atom false)
        num-samples (fn [cfg t] (int (* t (:sample-rate-hz cfg))))
        notes (vec (concat notes (repeat (max 0 (- (count times) (count notes))) 0)))
        times (vec (concat times (repeat (max 0 (- (count notes) (count times))) 0)))
        f (fn [cfg n]
            (if (nil? @counter)
              (reset! counter (num-samples cfg (nth times 0))))
            (loop [res nil
                   n n]
              (if (or (zero? n) @done)
                (if (zero? n) res (concat res (repeat n 0)))
                (let [nsamp (min n @counter)
                      n (- n nsamp)
                      smps (repeat nsamp (nth notes @index))]
                  (reset! counter (- @counter nsamp))
                  (when (zero? @counter)
                    (if (and (not looping) (= @index (dec (count notes))))
                      (reset! done true))
                    (reset! index (mod (inc @index) (count notes)))
                    (reset! counter (num-samples cfg (nth times @index))))
                  (recur (concat res smps)
                         n)))))]
    (add-node! (ugen-fn f) "sequencer")))

(defn- find-retrigger-index
  [slc i last-gate n]
  (github.com$jfhamlin$muscrat$pkg$slice.FindIndexOfRisingEdge slc i last-gate))

(defn choose-gate
  [gate opts]
  (let [last-gate (atom 0)
        choice-index (atom (rand-int (count opts)))]
    (let [f (fn [cfg n]
              (let [inputs (:input-samples cfg)
                    trigs (get inputs "trigger")]
                (loop [res nil
                       remain n
                       lg @last-gate]
                  (if (zero? remain)
                    (do
                      (reset! last-gate (get trigs (dec n)))
                      res)
                    (let [choice (get inputs (str "$" @choice-index))
                          index (- n remain)
                          next-choice-index (find-retrigger-index trigs index lg n)
                          nsamp (min remain (- next-choice-index index))
                          start index
                          end (+ start nsamp)
                          smps (go/slice choice start end)]
                      (if (< next-choice-index n)
                        (reset! choice-index (rand-int (count opts))))
                      (recur (concat res smps)
                             (- remain nsamp)
                             (get trigs (min (dec n) (inc end)))))))))]
      (let [opt-nodes (map as-node opts)
            node (add-node! (ugen-fn f) "choose-gate")]
        (doseq [[on i] (map vector opt-nodes (range (count opt-nodes)))]
          (add-edge! on node (str "$" i)))
        (add-edge! (as-node gate) node "trigger")
        node))))
