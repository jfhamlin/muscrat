(ns mrat.core
  (:import (github.com$jfhamlin$muscrat$pkg$graph Node
                                                  WithLabel)
           (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum
                                                 NewProduct)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Generator
                                                    Table
                                                    WithDefaultDutyCycle
                                                    WithMultiply
                                                    WithAdd
                                                    Sin
                                                    Saw
                                                    Tri
                                                    Pulse
                                                    Phasor)
           (github.com$jfhamlin$muscrat$pkg$stochastic NewNoise
                                                       NewPinkNoise)
           (github.com$jfhamlin$muscrat$pkg$mod NewEnvelope)
           (github.com$jfhamlin$muscrat$pkg$effects NewFreeverb
                                                    NewLowpassFilter)
           (github.com$jfhamlin$muscrat$pkg$sampler NewSampler
                                                    LoadSample)
           (github.com$jfhamlin$muscrat$pkg$aio NewInputDevice
                                                NewQwertyMIDI)
           (github.com$jfhamlin$freeverb-go NewRevModel)))

(def ^:dynamic *graph* nil)

(defn- add-node!
  [ug label]
  (.AddGeneratorNode *graph* ug (WithLabel (str label))))

(defn- add-edge!
  [x y port] (.AddEdge *graph* (.ID x) (.ID y) port))

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(extend-protocol AsNode
  Node
  (as-node [n] n))

(extend-protocol AsNode
  float64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  int64
  (as-node [x] (add-node! (NewConstant x) x)))

(defn play
  ([ch] (play ch ch))
  ([ch & channels]
   (let [channels (cons ch channels)
         num-sinks (count (. *graph* sinks))
         ch-inds (map vector channels (range (count channels)))]
     (doseq [[ch i] ch-inds]
       (let [gen (as-node ch)
             chan-id (+ num-sinks i)
             sink (.AddSinkNode *graph* (WithLabel (fmt.Sprintf "out%d" chan-id)))]
         (add-edge! gen sink "w")))))) ;; TODO: "w" seems wrong

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

(defn pow
  [b e] (math.Pow b e)) ;; TODO: use glojure.math

(defn decibels [db] (pow 10 (/ db 20.0)))

(defn cents [x] (pow 2 (/ x 1200.0)))
(defn semitones [x] (pow 2 (/ x 12.0)))
(defn octaves [x] (pow 2 x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

(defn- +-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-sum (apply glojure.core/+ nums)]
    (if (empty? ugens)
      num-sum
      (let [sum-node (add-node! (NewSum) "+")
            nodes (if (zero? num-sum) ugens
                      (conj ugens (add-node! (NewConstant num-sum) num-sum)))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n sum-node (str \$ i)))
        sum-node))))

(defn +
  "Return the sum of any combination of numbers or ugens.
  If any argument to + is a node, then the result of + is a node"
  ([] 0)
  ([x] x)
  ([x & more] (apply +-internal (cons x more))))

(defn -
  "Return the difference of any combination of numbers or ugens.
  If any argument to - is a node, then the result of - is a node"
  ([] 0)
  ([x] (* -1 x))
  ([x & more] (+ x (apply + (map #(* -1 %) more)))))

(defn- *-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-prod (apply glojure.core/* nums)]
    (if (empty? ugens)
      num-prod
      (let [prod-node (add-node! (NewProduct) "*")
            nodes (conj ugens (add-node! (NewConstant num-prod) num-prod))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n prod-node (str \$ i)))
        prod-node))))

(defn *
  "Return the product of any combination of numbers or ugens.
  If any argument to * is a node, then the result of * is a node."
  ([] 1)
  ([x] x)
  ([x & more] (apply *-internal (cons x more))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(def default-freq 440)

(defn- validate-flags
  [flags defaults]
  (if (odd? (count flags))
    (throw (apply str "odd number of flag args: " (interpose \, unsupported))))
  (let [m (reduce #(apply assoc %1 %2) {} (partition 2 flags))
        unsupported (seq (remove (set (keys defaults)) (keys m)))]
    (if unsupported (throw (apply str "unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (merge defaults m)))

(defn- handle-extra-gen-args
  [node args-map]
  (doseq [[k v] args-map]
    (let [gen (as-node v)
          param (k {:iphase "iphase"
                    :phase "phase"
                    :sync "sync"
                    :duty "dc"})]
      (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
      (add-edge! gen node param))))

(defmacro defwtosc
  [name wavtab & default-args]
  (let [fn-name (symbol (str name))
        default-args (vec default-args)]
    `(defn ~fn-name
       ([] (~fn-name default-freq))
       ([freq# & args#]
        (if (keyword? freq#)
          (apply ~fn-name default-freq freq# args#)
          (do
            (if (odd? (count args#))
              (throw (fmt.Errorf "%s: odd number of flag args: %v" (str ~name) args#)))
            (let [args# (if (empty? ~default-args) args# (concat ~default-args args#))
                  args# (reduce #(apply assoc %1 %2) {} (partition 2 args#))
                  wt-opts# [(~'WithDefaultDutyCycle (get args# :default-duty 1))
                            (~'WithMultiply (get args# :mul 1.0))
                            (~'WithAdd (get args# :add 0.0))]
                  args# (dissoc args# :default-duty :mul :add)
                  gen# (apply ~'Generator (~wavtab 1024) wt-opts#)
                  label# (~'WithLabel ~(str name))
                  osc-node# (add-node! gen# label#)
                  freq-node# (as-node freq#)]
              (add-edge! freq-node# osc-node# "w")
              (handle-extra-gen-args osc-node# args#)
              osc-node#)))))))

(defwtosc sin Sin)
(defwtosc saw Saw)
(defwtosc tri Tri)
(defwtosc phasor Phasor)
(defwtosc pulse Pulse :default-duty 0.5)
(defwtosc sqr Pulse :default-duty 0.5)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Noise

;; todo: add/mul flags

(defn noise
  ([] (noise 0))
  ([freq] (add-node! (NewNoise freq) "noise")))

(defn pink-noise
  []
  (add-node! (NewPinkNoise) "pink-noise"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modulators

(defn env
  [gate levels times & opts]
  (let [trigger (as-node gate)
        levels (map as-node levels)
        times (map as-node times)]
    (if (not= (count levels) (inc (count times)))
      (throw (str "env expects the number of levels to be one more than the number of times, got " (count levels) " levels and " (count times) " times.")))
    (let [env-node (add-node! (NewEnvelope "lin") "envelope")]
      (add-edge! trigger env-node "trigger")
      (doseq [[n i] (map vector levels (range (count levels)))]
        (add-edge! n env-node (str "level$" i)))
      (doseq [[n i] (map vector times (range (count times)))]
        (add-edge! n env-node (str "time$" i)))
      env-node)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Effects

(defn- freeverb-gen
  [& opts]
  (let [opts (apply hash-map opts)
        supported #{:dry :wet :room-size :damp :width}
        unsupported (seq (remove supported (keys opts)))
        dry (get opts :dry 0.5)
        wet (get opts :wet 0.5)
        room-size (get opts :room-size 0.5)
        damp (get opts :damp 0.5)
        width (get opts :width 1.0)]
    (if unsupported (throw (apply str "freeverb: unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (NewFreeverb
     (doto (NewRevModel)
       (.SetDry dry)
       (.SetWet wet)
       (.SetRoomSize room-size)
       (.SetDamp damp)
       (.SetWidth width)))))

(defn freeverb
  [node & opts]
  (let [fv-node (add-node! (apply freeverb-gen opts) "freeverb")]
    (add-edge! node fv-node "$0")
    fv-node))

(defn lores
  [n cutoff res]
  (let [n (as-node n)
        cutoff (as-node cutoff)
        res (as-node res)
        lpf (add-node! (NewLowpassFilter) "lores")]
    (add-edge! n lpf "in")
    (add-edge! cutoff lpf "cutoff")
    (add-edge! res lpf "resonance")
    lpf))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sampler

(defn load-sample
  [path] (LoadSample path))

(defn sampler
  ([sample & flags]
   (let [flags (validate-flags flags {:loop true})
         node (add-node! (NewSampler (seq sample) (:loop flags)) "sampler")]
     node)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; I/O devices

(defn soundin
  []
  (add-node! (NewInputDevice) "in"))

(defn qwerty-midi
  []
  (let [midi (NewQwertyMIDI)
        trig (.AsTrigger midi)]
    [(add-node! midi "qwerty-midi")
     (add-node! trig "qwerty-trig")]))


;; (def *delay mrat.effects/delay)
;; (def *clip mrat.effects/clip)
;; (def *trand mrat.math.rand/trand)
;; (def *env mrat.effects/env)

;; (def rand mrat.math.rand/rand)

;; (defn remap
;;   "Remap a value from [min-in, max-in] to [min-out, max-out].
;;   If not provided, [min-in, max-in] defaults to [-1, 1]"
;;   ([x min max] (remap x -1 1 min max)
;;   ([x min-in max-in min max]
;;    (let [range-in (- max-in min-in)
;;          range-out (- max min)
;;          x (- x min-in)]
;;      (+ min (/ (* x range-out) range-in)))))

;; (defn decibels [db] (pow 10 (/ db 20)))

;; (def *mixer
;;   (fn [& args]
;;     (let ((mixerArgs args))
;;       (let ((weightSum (reduce + 0
;;                                (map-idx (fn [val idx] (if (even? idx) val 0)) mixerArgs))))
;;         (sum (map (fn [idx] (let ((weight (nth mixerArgs (* 2 idx)))
;;                                   (chan   (nth mixerArgs (+ (* 2 idx) 1))))
;;                               (* (/ weight weightSum) chan)))
;;                   (range 0 (/ (length mixerArgs) 2))))))))

;; ;;; TODO: move to a library for music theory.
;; (defn cents [x] (pow 2 (/ x 1200)))
;; (defn semitones [x] (pow 2 (/ x 12)))
;; (defn octaves [x] (pow 2 x))
