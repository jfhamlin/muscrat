(ns mrat.core
  (:import (github.com$glojurelang$glojure$pkg$lang *Ratio *BigInt)
           (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum
                                                 NewMovingAverage
                                                 NewProduct
                                                 NewFMA
                                                 NewFMAStatic
                                                 NewQuotient
                                                 NewMax
                                                 NewMin
                                                 NewAbs
                                                 NewExp
                                                 NewLog2
                                                 NewPow
                                                 NewTanh
                                                 NewLinExp
                                                 NewLatch
                                                 NewCopySign
                                                 NewFreqRatio
                                                 NewMIDIFreq
                                                 NewImpulse
                                                 NewPulseDiv
                                                 NewKnob
                                                 NewHydra
                                                 NewScope
                                                 SimpleUGenFunc
                                                 WithInterp
                                                 WithDefaultDutyCycle
                                                 InterpNone
                                                 InterpLinear
                                                 InterpCubic)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Table)
           (github.com$jfhamlin$muscrat$pkg$osc NewSine
                                                NewSaw
                                                NewTri
                                                NewPulse
                                                NewPhasor
                                                NewLFSaw
                                                NewLFPulse)
           (github.com$jfhamlin$muscrat$pkg$stochastic NewRRand
                                                       NewNoise
                                                       NewNoiseQuad
                                                       NewPinkNoise)
           (github.com$jfhamlin$muscrat$pkg$mod NewEnvelope
                                                WithReleaseNode
                                                WithCurve)
           (github.com$jfhamlin$muscrat$pkg$effects NewAmplitude
                                                    NewFreeverb
                                                    NewBitcrusher
                                                    NewLimiter
                                                    NewLowpassFilter
                                                    NewRLPF
                                                    NewRHPF
                                                    NewBPF
                                                    NewLoShelf
                                                    NewHiShelf
                                                    NewPeakEQ
                                                    NewDelay
                                                    NewAllPass
                                                    NewWaveFolder
                                                    NewClip
                                                    NewPitchShift)
           (github.com$jfhamlin$muscrat$pkg$sampler NewSampler
                                                    LoadSample)
           (github.com$jfhamlin$muscrat$pkg$aio NewInputDevice
                                                NewSoftwareKeyboard
                                                NewMIDIInputDevice
                                                WithVoices
                                                WithDeviceID
                                                WithDeviceName
                                                WithChannel
                                                WithController
                                                WithDefaultValue
                                                NewWavOut)
           (github.com$jfhamlin$freeverb-go NewRevModel)))

(defn- docgroup
  "Add a 'docgroup' metadata key with the provided value to all public
  vars defined in the mrat.core namespace that do not already have a
  'docgroup' key."
  [docgroup]
  (doseq [v (vals (ns-publics *ns*))
          :when (and (var? v) (not (:docgroup (meta v))))]
    (alter-meta! v assoc :docgroup docgroup)))

(def SAMPLE-RATE github.com$jfhamlin$muscrat$pkg$conf.SampleRate)
(def BUFFER-SIZE github.com$jfhamlin$muscrat$pkg$conf.BufferSize)
(def BUFFER-DUR (/ BUFFER-SIZE SAMPLE-RATE))
(def SAMPLE-DUR (/ 1 SAMPLE-RATE))

(def ^:dynamic *sample-file-paths*
  (atom (vec github.com$jfhamlin$muscrat$pkg$conf.SampleFilePaths)))

(docgroup "Constants")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmacro ^:private doseq-idx
  [[locals seq-expr] & body]
  `(let [s# ~seq-expr]
     (doseq [~locals (map vector s# (range (count s#)))]
       ~@body)))

(def ^:private next-id (atom 0))
(defn- gen-id
  "Generate a new unique id."
  []
  (str (swap! next-id inc)))

(defmacro -<
  "Threads the result of the expression through each of the
   forms.

   (-< exp
      ((fn1 ...) (fn2 ...))
      ...)

   is equivalent to

   (let [x exp]
     (-> x (fn1 ...) (fn2 ...))
     ..."
  [exp & forms]
  (let [exp-sym (gensym)
        res-sym (gensym)]
    `(let [~exp-sym ~exp
           ~res-sym ~(mapv (fn [form] `(-> ~exp-sym ~@form))
                           forms)]
       ~res-sym)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Graph

(def ^:dynamic *graph* (atom {:nodes [] :edges []}))

(defn- sinks
  "Return the sink nodes of the graph."
  [graph]
  (->> graph
       :nodes
       (filter :sink)
       (map :id)))

(defn- outputs
  "Return the output nodes of the graph. Outputs are sinks whose :ug type is :out."
  [graph]
  (->> graph
       :nodes
       (filter (fn [{:keys [sink type]}] (or sink (= type :out))))
       (map :id)))

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(defn- is-node?
  [x]
  (boolean (and (map? x) (:id x))))

(declare add-edge!)
(declare constant-node)

(defn- add-node!
  [type ctor & {:keys [key args sink in-edges]}]
  (let [node {:id (gen-id)
              :type type
              :ctor ctor
              :args args
              :key key
              :sink sink}]
    (swap! *graph* update-in [:nodes] conj node)
    (doseq [[port val] in-edges]
      (add-edge! (as-node val) node (name port)))
    node))

(defn- add-edge!
  [{x-id :id} {y-id :id} port]
  (let [edge {:from x-id :to y-id :port port}]
    (swap! *graph* update-in [:edges] conj edge)
    edge))

(extend-protocol AsNode
  github.com$glojurelang$glojure$pkg$lang.IPersistentMap
  (as-node [n] n))

(extend-protocol AsNode
  go/float64
  (as-node [x] (constant-node x)))

(extend-protocol AsNode
  go/int64
  (as-node [x] (constant-node x)))

(extend-protocol AsNode
  go/int
  (as-node [x] (constant-node x)))

(extend-protocol AsNode
  go/bool
  (as-node [x]
    (let [val (if x 1 0)]
      (constant-node val))))

(extend-protocol AsNode
  *BigInt
  (as-node [x] (constant-node x)))

(extend-protocol AsNode
  *Ratio
  (as-node [x] (constant-node x)))

(defn play
  [channels]
  (let [channels (if-not (or (seq? channels)
                             (vector? channels)) [channels channels] channels)
        channels (if (= (count channels) 0) [0 0] channels)
        channels (if (= (count channels) 1) [(first channels) (first channels)] channels)
        ch-inds (map vector channels (range (count channels)))
        find-or-create-sink (fn [i]
                              (let [outputs (filter #(= (:type %) :out) (:nodes @*graph*))
                                    sink (first (filter #(= (first (:args %)) i) outputs))]
                                (if sink
                                  sink
                                  (add-node! :out nil :args [i] :sink true))))]
    (doseq [[ch i] ch-inds]
      (let [gen (as-node ch)
            sink (find-or-create-sink i)
            port (str "in" (count (:edges @*graph*)))]
        ;; port name doesn't matter for out nodes
        (add-edge! gen sink port)))))

(docgroup "Output")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn- constant-node
  [x]
  (add-node! :const NewConstant :args [(double x)]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper for custom sample generators

(defn ugen-fn
  "Returns a UGenFunc that wraps the given function. The function should
  take a map of configuration parameters and an output buffer, and
  write samples to the output buffer."
  [f]
  (let [wrapped (fn [cfg out]
                  (f {:sample-rate-hz (.SampleRateHz cfg)
                      :input-samples (.InputSamples cfg)}
                     out))]
    (SimpleUGenFunc wrapped)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

(defn- seq-or-vec?
  [x]
  (or (seq? x) (vector? x)))

(defn- arrange-multi-channel-args
  "Arrange a collection of arguments, some of which may be collections,
  into a sequence of sequences, where the i-th subsequence is an
  arguments sequence composed of the i-th element of each argument
  collection, wrapping around the collection for those shorter than
  the collection with maximum length.

  For example:
    (arrange-multi-channel-args [[1 2 3] [4 5] [6 7 8 9]])
  returns:
    ([1 4 6] [2 5 7] [3 4 8] [1 5 9])"
  [args]
  (let [colls (map #(if (seq-or-vec? %) % [%]) args)
        colls-counts (map count colls)
        max-len (apply max 0 colls-counts)
        colls (map #(take max-len (cycle %)) colls)]
    (if (empty? colls)
      '([])
      (apply map vector colls))))

(defn- +-internal
  [& xs]
  (let [groups (group-by #(is-node? %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-sum (apply glojure.core/+ nums)]
    (if (empty? ugens)
      num-sum
      (let [sum-node (add-node! :+ NewSum)
            nodes (if (zero? num-sum)
                    ugens
                    (conj ugens (constant-node num-sum)))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n sum-node (str \$ i)))
        sum-node))))

(defn +
  "Return the sum of any combination of numbers or ugens.
  If any argument to + is a node, then the result of + is a node.  If
  any argument to + is a collection, then the result is a collection
  whose length is the length of the longest collection (max-len) and
  where the elements of each argument are added pairwise. Any
  non-collections are duplicated to max-len, and any collections
  shorter than max-len are cycled up to max-len."
  ([] 0)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some seq-or-vec? args)
       (let [colls (map #(if (seq-or-vec? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map + colls))
       (apply +-internal args)))))

(declare *)

(defn -
  "Return the difference of any combination of numbers or ugens.
  If any argument to - is a node, then the result of - is a node"
  ([] 0)
  ([x] (* -1 x))
  ([x & more] (+ x (apply + (map #(* -1 %) more)))))

(defn- *-internal
  [& xs]
  (let [groups (group-by #(is-node? %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-prod (apply glojure.core/* nums)]
    (if (empty? ugens)
      num-prod
      (let [prod-node (add-node! :* NewProduct)
            nodes (conj ugens (constant-node num-prod))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n prod-node (str \$ i)))
        prod-node))))

(defn *
  "Return the product of any combination of numbers or ugens.
  If any argument to * is a node, then the result of * is a node."
  ([] 1)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some seq-or-vec? args)
       (let [colls (map #(if (seq-or-vec? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map * colls))
       (apply *-internal args)))))

(defn- div-internal
  [& xs]
  (if (every? #(not (is-node? %)) xs)
    (apply glojure.core// xs)
    (let [quot-node (add-node! :/ NewQuotient)
          nodes (map as-node xs)]
      (doseq [[n i] (map vector nodes (range (count nodes)))]
        (add-edge! n quot-node (str \$ i)))
      quot-node)))

(defn /
  "Return the quotient of any combination of numbers or ugens.
  If any argument to / is a node, then the result of / is a node."
  ([x] (/ 1 x))
  ([x & more]
   (let [args (cons x more)]
     (if (some seq-or-vec? args)
       (let [colls (map #(if (seq-or-vec? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map / colls))
       (apply div-internal args)))))

(defn sum
  [coll] (apply + coll))

(defn fma
  "A fused multiply and add ugen."
  [in mul add]
  (if (seq-or-vec? in) ;; handle multiple channels
    (map #(fma % mul add) in)
    (if (and (every? number? [mul add])
             (== mul 1)
             (== add 0))
      in ;; no-op
      (let [node (if (every? number? [mul add])
                   (add-node! :fma NewFMAStatic :args [mul add]) ;; optimized for static mul and add
                   (let [n (add-node! :fma NewFMA)]
                     (add-edge! (as-node mul) n "mul")
                     (add-edge! (as-node add) n "add")
                     n))]
        (add-edge! (as-node in) node "in")
        node))))

(docgroup "Operators")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; macros

(defmacro defugen
  "Defines a new generator node constructor with semantics similar to defn,
  but with specific constraints and enhancements for argument
  handling.  This macro allows only a single arity and requires the
  argument vector to be defined in pairs. Each pair consists of an
  argument name followed by its default value. When the resulting
  function is called, all parameters are optional; unprovided
  parameters default to their specified values. Additionally, callers
  can provide arguments out of their original order or skip certain
  arguments by using keyword-value pairs, where the keyword matches
  the argument name. This feature offers flexibility in how arguments
  are passed to the function, allowing for more dynamic and adaptable
  function calls."
  [name & decl]
  (let [[doc args & body] (if (string? (first decl))
                            decl
                            (cons "" decl))
        ;; partition the args into pairs of arg-name and default value
        ;; the default value may optionally be followed by a docstring
        arg-pairs (loop [args args
                         arg-pairs []]
                    (if (empty? args)
                      arg-pairs
                      (let [arg-name (first args)
                            default (second args)
                            args (drop 2 args)
                            [doc args] (if (string? (first args))
                                         [(first args) (rest args)]
                                         [nil args])
                            pre-meta (meta arg-name)
                            new-meta (if pre-meta
                                       (assoc pre-meta :doc doc)
                                       {:doc doc})
                            arg-name (with-meta arg-name new-meta)]
                        (recur args
                               (conj arg-pairs [arg-name default])))))
        arg-names (mapv (comp keyword first) arg-pairs)
        ;; noexpands are the arguments that don't support multi-channel expansion
        ;; they are denoted by names with {:noexpand true} in metadata
        noexpands (into #{} (->> arg-pairs
                                (map first)
                                (filter (comp :noexpand meta))
                                (map keyword)))
        defaults (into {} (map (fn [[k v]] [(keyword k) v]) arg-pairs))
        allowed-keys (merge (set (keys defaults)) :mul :add)
        assignments-sym (gensym "assignments")]
    `(do
       (defn ~name ~doc [& args#]
         (let [defaults# ~defaults
               ~assignments-sym (loop [assignments# {}
                                       arg-names# ~arg-names
                                       args# args#]
                                  (if (or (empty? args#)
                                          (contains? ~allowed-keys (first args#)))
                                    (merge assignments# (apply hash-map args#))
                                    (if (empty? arg-names#)
                                      (throw (errors.New "too many positional arguments"))
                                      (recur (assoc assignments# (first arg-names#) (first args#))
                                             (rest arg-names#)
                                             (rest args#)))))
               ~assignments-sym (merge defaults# ~assignments-sym)
               ;; duplicate the argument pairs for each argument value
               ;; to handle multiple channels.
               expand-arg# (fn [[k# v#]] (if (and (not (contains? ~noexpands k#))
                                                  (seq-or-vec? v#))
                                           (map #(vector k# %) v#)
                                           [[k# v#]]))
               arg-lists# (arrange-multi-channel-args (map expand-arg# (seq ~assignments-sym)))
               channels# (for [arg-list# arg-lists#]
                           (let [~assignments-sym (into {} arg-list#)
                                 ~@(mapcat (fn [[arg-name default]]
                                             `(~arg-name (get ~assignments-sym ~(keyword arg-name))))
                                           arg-pairs)
                                 ugen# (do ~@body)
                                 mul# (get ~assignments-sym :mul 1)
                                 add# (get ~assignments-sym :add 0)]
                             (fma ugen# mul# add#)))]
           (if (= 1 (count channels#))
             (first channels#)
             channels#)))
       ;; add :ugenargs metadata to the function. each arg will get a map
       ;; with name, efault value, and docstring (if available as :doc
       ;; metadata on the arg)
       (let [ugenargs# ~(mapv #(let [[name default] %]
                                 {:name (str name)
                                  :default default
                                  :doc (or (-> name meta :doc) "")})
                              arg-pairs)]
         (alter-meta! (var ~name) assoc :ugenargs ugenargs#)))))

(docgroup "Macros")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

(defn pow
  "Returns b^p. If b or p are nodes, creates a new node that computes b^p. Else,
  returns the result of b^p directly. pow extends exponentiation to
  allow for a negative base with a non-integral exponent, returning
  -((-b)^p) when b is negative."
  [b p]
  (if (some (partial is-node?) [b p])
    (add-node! :pow NewPow :in-edges {"base" b "exp" p})
    (if (neg? b)
      (- (math.Pow (- b) p))
      (math.Pow b p))))

(defn sine
  "Returns sin(theta). If theta is a node, creates a new node that
  computes sin(theta). Else, returns the result of sin(theta)
  directly."
  [theta]
  (if (is-node? theta)
    (add-node! :sine github.com$jfhamlin$muscrat$pkg$ugen.NewSine :in-edges {:in theta})
    (math.Sin theta)))

(defn min
  "Returns the minimum of xs. If any element of xs is a node, creates a new
  node that computes the minimum of xs. Else, returns the minimum of xs"
  [& xs]
  (if (some is-node? xs)
    (add-node! :min NewMin :in-edges (zipmap (map str (range (count xs))) xs))
    (apply glojure.core/min xs)))

(defn max
  "Returns the maximum of xs. If any element of xs is a node, creates a new
  node that computes the maximum of xs. Else, returns the maximum of xs"
  [& xs]
  (if (some is-node? xs)
    (add-node! :max NewMax :in-edges (zipmap (map str (range (count xs))) xs))
    (apply glojure.core/max xs)))

(defn abs
  "Returns the absolute value of x. If x is a node, creates a new node
  that computes the absolute value of x. Else, returns the absolute
  value of x directly."
  [x]
  (if (is-node? x)
    (add-node! :abs NewAbs :in-edges {:in x})
    (math.Abs (double x))))

(defn exp
  "Returns e^x. If x is a node, creates a new node that computes e^x.
  Else, returns e^x directly."
  [x]
  (if (is-node? x)
    (add-node! :exp NewExp :in-edges {:in x})
    (math.Exp x)))

(defugen log2
  "Returns the base-2 logarithm of x. If x is a node, creates a new node
  that computes the base-2 logarithm of x. Else, returns the base-2 logarithm
  of x directly."
  [x 1]
  (if (is-node? x)
    (add-node! :exp NewLog2 :in-edges {:in x})
    (math.Log2 x)))

(defugen tanh
  "Returns the hyperbolic tangent of x. If x is a node, creates a new
  node that computes the hyperbolic tangent of x. Else, returns the
  hyperbolic tangent of x directly."
  [x 0]
  (if (is-node? x)
    (add-node! :tanh NewTanh :in-edges {:in x})
    (math.Tanh x)))

(defn linexp
  "Maps x from the linear range [srclo, srchi] to the exponential
  range [dstlo, dsthi]"
  [x srclo srchi dstlo dsthi]
  (add-node! :linexp NewLinExp :in-edges {:in x
                                          :srclo srclo
                                          :srchi srchi
                                          :dstlo dstlo
                                          :dsthi dsthi}))

(defn copy-sign
  "Returns x with the sign of s. If x or s are nodes, creates a new node
  that computes x with the sign of s. Else, returns x with the sign of
  s directly."
  [x s]
  (if (or (is-node? x) (is-node? s))
    (add-node! :copy-sign NewCopySign :in-edges {"in" x "sign" s})
    (math.Copysign x s)))

(defn- freq-ratio
  [x kind]
  (add-node! :freq-ratio NewFreqRatio :args [kind] :in-edges {"in" x}))

(defn dbamp
  "Return the amplitude ratio corresponding to the given decibel value."
  [db]
  (if (is-node? db)
    (freq-ratio db "decibels")
    (pow 10 (/ db 20.0))))

(defn cents
  "Return the frequency ratio corresponding to the given number of
  cents."
  [x]
  (if (is-node? x)
    (freq-ratio x "cents")
    (pow 2 (/ x 1200.0))))

(defn semitones
  "Return the frequency ratio corresponding to the given number of
  semitones."
  [x]
  (if (is-node? x)
    (freq-ratio x "semitones")
    (pow 2 (/ x 12.0))))

(defn octaves
  "Return the frequency ratio corresponding to the given number of
  octaves."
  [x]
  (if (is-node? x)
    (freq-ratio x "octaves")
    (pow 2 x)))

(defugen mtof
  "Return the frequency corresponding to the given MIDI note number."
  [note 69]
  (if (is-node? note)
    (add-node! :midifreq NewMIDIFreq :in-edges {"in" note})
    (* 440.0 (pow 2 (/ (- note 69.0) 12.0)))))

(defn lcm
  [& x]
  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))
          (lcm [a b] (/ (* a b) (gcd a b)))]
    (reduce lcm x)))

(defugen moving-avg
  "Calculates a running average over a window of samples. The window size is
   given as a duration."
  [in 0
   dur 0.001
   max-dur 0.01]
  (let [in-node (as-node in)
        dur-node (as-node dur)
        node (add-node! :moving-avg NewMovingAverage
                        :args [max-dur]
                        :in-edges {"in" in-node "dur" dur-node})]
    node))

(defn scope
  "Passes signal through unchanged while displaying it in an oscilloscope.
   Options:
   :name - Display name for the scope
   :buffer-size - Number of samples to display (default 2048)"
  [signal & {:keys [name buffer-size]
             :or {name "Scope" buffer-size 2048}}]
  (let [signal-node (as-node signal)
        scope-node (add-node! :scope NewScope
                              :args [name buffer-size]
                              :sink true)]
    (add-edge! signal-node scope-node "in")
    signal))

(docgroup "Utilities")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(def ^:private default-freq 440)

(defn- validate-flags
  [flags defaults]
  (if (odd? (count flags))
    (throw (apply str "odd number of flag args: " (interpose \, flags))))
  (let [m (reduce #(apply assoc %1 %2) {} (partition 2 flags))
        unsupported (seq (remove (set (keys defaults)) (keys m)))]
    (if unsupported (throw (apply str "unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (merge defaults m)))

(defn- handle-extra-gen-args
  [node args-map]
  (doseq [[k v] args-map]
    (let [gen (as-node v)
          param (k {:iphase "iphase"
                    :phase "phase"
                    :sync "sync"
                    :duty "dc"})]
      (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
      (add-edge! gen node param))))

(defmacro ^:private defosc
  [name ctor & {:keys [default-duty] :or {default-duty 1}}]
  (let [opt-args '[duty iphase sync phase]]
    `(defugen ~name
       [~'freq default-freq
        ~@(mapcat #(vector % nil) opt-args)]
       (let [wt-opts# [(~'WithDefaultDutyCycle ~default-duty)]
             type# ~(keyword name)
             osc-node# (add-node! type# ~ctor :args wt-opts#)
             freq-node# (as-node ~'freq)
             extra-args# ~(mapv #(vector (keyword %) %) opt-args)
             extra-args# (into {} (remove (comp nil? second) extra-args#))]
         (add-edge! freq-node# osc-node# "w")
         (handle-extra-gen-args osc-node# extra-args#)
         osc-node#))))

(defosc sin NewSine)
(defosc saw NewSaw)
(defosc tri NewTri)
(defosc phasor NewPhasor)

(defosc pulse NewPulse :default-duty 0.5)
(defosc sqr NewPulse :default-duty 0.5)

(defosc lfsaw NewLFSaw)
(defosc lfpulse NewLFPulse :default-duty 0.5)
(defosc lfsqr NewLFPulse :default-duty 0.5)

(defugen impulse
  [freq default-freq
   iphase nil
   sync nil] ;; TODO: implement sync
  (let [iphase (if iphase (as-node iphase))
        freq-node (as-node freq)
        node (add-node! :impulse NewImpulse)]
    (if iphase (add-edge! iphase node "iphase"))
    (if sync (add-edge! sync node "sync"))
    (add-edge! freq-node node "w")
    node))

(defugen pulse-div
  "Outputs one impulse each time it receives a certain number of
  triggers at its input."
  [trigger 0
   div 2
   start 0]
  (add-node! :pulse-div NewPulseDiv
             :args [start]
             :in-edges {:trigger trigger :div div}))

(docgroup "Oscillators")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Noise/Randomness

(defugen noise
  "Generates random values between -1 and 1 at the given frequency.
  If frequency is zero or not provided, generates white
  noise."
  [freq 0 "Frequency with which to generate random values. If zero, generates white noise."]
  (add-node! :noise NewNoise :in-edges {:w freq}))

(defugen pink-noise
  []
  (add-node! :pink-noise NewPinkNoise))

(defugen noise-quad
  "Generates quadratically-interpolated random values between -1 and 1
  at the given frequency. If frequency is zero or not provided,
  generates at 500 hz."
  [freq 500 "Frequency with which to generate random values."]
  (add-node! :noise-quad NewNoiseQuad :in-edges {:w freq}))

(defugen rrand
  "Generates random values between the given min and max values
  when triggered."
  [min 0 "Minimum value."
   max 1 "Maximum value."
   trigger 1 "Trigger to generate a new random value."
   ^:noexpand seed 0 "Seed for the random number generator."]
  (let [add min
        mul (- max min)
        rnd (math$rand.New (math$rand.NewSource seed))]
    (if (and (number? trigger) (> trigger 0))
      (fma (.Float64 rnd) mul add)
      (add-node! :rrand NewRRand :args [rnd] :in-edges {:min min :max max :trig trigger}))))

(docgroup "Random")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modulators

(defn env
  [gate levels times & flags]
  (let [flags (validate-flags flags {:curve :lin, :release-node -1})
        curve (:curve flags)
        curve (if (coll? curve) curve [curve])
        curve (map #(if (keyword? %) (name %) (double %)) curve)
        trigger (as-node gate)
        levels (map as-node levels)
        times (map as-node times)]
    (if (not= (count levels) (inc (count times)))
      (throw (str "env expects the number of levels to be one more than the number of times, got " (count levels) " levels and " (count times) " times.")))
    (let [env-node (add-node! :envelope #(NewEnvelope (WithCurve %1) (WithReleaseNode %2))
                              :args [curve (:release-node flags)])]
      (add-edge! trigger env-node "trigger")
      (doseq [[n i] (map vector levels (range (count levels)))]
        (add-edge! n env-node (str "level$" i)))
      (doseq [[n i] (map vector times (range (count times)))]
        (add-edge! n env-node (str "time$" i)))
      env-node)))

;; alias for env
(def envelope env)

(defn env-asr
  [gate [a s r] & {:keys [curve]}]
  (env gate [0 s 0] [a r] :release-node 1 :curve (or curve :lin)))

(defn env-adsr
  [gate [a d s r] & {:keys [curve]}]
  (env gate [0 1 s 0] [a d r] :release-node 2 :curve (or curve :lin)))

(defn env-perc
  [gate [a d] & {:keys [curve]}]
  (env gate [0 1 0] [a d] :curve (or curve :lin)))

(defugen line
  "Generates a line from the start value to the end value over the given
  duration."
  [start 0 "The start value."
   end 1 "The end value."
   dur 1 "The duration of the line."]
  (env 1 [start end] [dur] :curve :lin))

(defugen xline
  "Generates an exponential curve from the start value to the end
  value. Both the start and end values must be non-zero and have the
  same sign."
  [start 1 "The start value."
   end 1 "The end value."
   dur 1 "The duration of the line."]
  (env 1 [start end] [dur] :curve :exp))

(docgroup "Envelopes")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Filters and Effects, multiple groups

(defugen amplitude
  "Tracks the peak amplitude of a signal."
  [in 0 "The signal to be processed."
   attack-time 0.01 "The time in seconds for the amplitude to rise to a new value."
   release-time 0.01 "The time in seconds for the amplitude to fall to a new value."]
  (add-node! :amplitude NewAmplitude :args [attack-time release-time] :in-edges {:in in}))

(docgroup "Analysis")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defugen limiter
  "Limits the input amplitude to the given level. Limiter will not
  overshoot, but it needs to look ahead in the audio. Thus there is a
  delay equal to twice the value of the dur parameter.

  Limiter is completely transparent for an in-range signal."
  [in 0 "The signal to be processed."
   level 1 "The peak output amplitude level to which to normalize the input."
   dur 0.01 "aka lookAheadTime. The buffer delay time. Shorter times will produce smaller delays and quicker transient response times, but may introduce amplitude modulation artifacts."]
  (add-node! :limiter
             NewLimiter
             :args [dur]
             :in-edges {:in in
                        :amp level}))

(defugen clip
  "Clip an input signal when it exceeds threshold low/high values."
  [in 0 "The signal to be processed."
   lo -1 "The lower threshold value."
   hi 1 "The upper threshold value."]
  (if (some (partial is-node?) [in lo hi])
    (add-node! :clip NewClip
               :in-edges {:in in
                          :lo lo
                          :hi hi})
    (-> in
        (max lo)
        (min hi))))

(docgroup "Dynamics")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defugen lores
  "A simple lowpass filter with cutoff and resonance, modeled after the
  Max/MSP lores~ object."
  [in 0 "The signal to be processed."
   freq 1200 "The cutoff frequency in hertz."
   reson 0 "Sets a \"resonance factor\" between 0(minimum resonance) and 1(maximum resonance). Values very close to 1 may produce clipping with certain types of input signals."]
  (add-node! :lores NewLowpassFilter
             :in-edges {:in in
                        :cutoff freq
                        :resonance reson}))

(defugen rlpf
  "A resonant low-pass filter."
  [in 0 "The signal to be processed."
   freq 440 "The cutoff frequency in hertz."
   rq 1 "The reciprocal of Q (bandwidth / cutoffFreq)."]
  (add-node! :rlpf NewRLPF
             :in-edges {:in in
                        :freq freq
                        :reson rq}))

(defugen rhpf
  "A resonant high-pass filter."
  [in 0
   freq 440
   rq 1]
  (add-node! :rhpf NewRHPF
             :in-edges {:in in
                        :freq freq
                        :reson rq}))

(defugen bpf
  "A simple bandpass filter with center frequency and bandwidth.
   n - the input signal
   freq - the center frequency in hertz
   rq - the width of the filter, as a coefficient bandwidth/freq"
  [in 0
   freq 440
   rq 1]
  (add-node! :bpf NewBPF
             :in-edges {:in in
                        :w freq
                        :bw rq}))

(defugen loshelf
  [in 0
   freq 1200
   rs 1
   db 0]
  (add-node! :loshelf NewLoShelf
             :in-edges {:in in
                        :w freq
                        :rs rs
                        :db db}))

(defugen hishelf
  [in 0
   freq 1200
   rs 1
   db 0]
  (add-node! :hishelf NewHiShelf
             :in-edges {:in in
                        :w freq
                        :rs rs
                        :db db}))

(defugen peakeq
  [in 0
   freq 1200
   rq 1
   db 0]
  (add-node! :peakeq NewPeakEQ
             :in-edges {:in in
                        :w freq
                        :rq rq
                        :db db}))

(docgroup "Filters")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn pipe
  "Create a pipe, which copies the input to the output. The input may be
  set with pipeset!. This is useful for creating feedback loops."
  []
  (let [f (fn [cfg out]
            (when-let [in (get (:input-samples cfg) "in")]
              (go/copy out in)))]
    (add-node! :pipe ugen-fn :args [f])))

(defn pipeset!
  "Set the input of a pipe."
  [p in]
  (add-edge! (as-node in) p "in"))

(defugen freeverb
  [in 0
   mix 1/3
   room-size 0.5
   damp 0.5]
  (let [model (NewRevModel)]
    (add-node! :freeverb
               #(NewFreeverb model)
               :in-edges {:in in
                          :mix mix
                          :room-size room-size
                          :damp damp})))

(defn- -delay
  [in max-delay-time delay-time interp-opt]
  (add-node! :delay NewDelay :args [max-delay-time (WithInterp interp-opt)]
             :in-edges {:in in
                        :delay delay-time}))

(defugen delayn
  "Delay line with no interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2]
  (-delay in max-delay-time delay-time InterpNone))

(defugen delayl
  "Delay line with linear interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2]
  (-delay in max-delay-time delay-time InterpLinear))

(defugen delayc
  "Delay line with cubic interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2]
  (-delay in max-delay-time delay-time InterpCubic))

(defugen allpass
  "Allpass filter with no interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2
   decay-time 1]
  (add-node! :allpass NewAllPass :args [max-delay-time]
             :in-edges {:in in
                        :delaytime delay-time
                        :decaytime decay-time}))

(defn- comb-feedback
  [delay-time decay-time]
  (if (or (and (not (is-node? delay-time)) (zero? delay-time))
          (and (not (is-node? decay-time)) (zero? decay-time)))
    0.0
    (let [abs-decay (abs decay-time)
          power (/ (* (math.Log 0.001) delay-time) abs-decay)
          absret (exp power)]
      (copy-sign absret decay-time))))

(defn- -comb
  [in max-delay-time delay-time decay-time delay-fn]
  (let [feedback (pipe)
        ;; there is a fixed delay time of BUFFER-DUR
        delay-time (max 0 (- delay-time BUFFER-DUR))
        delay (delay-fn feedback max-delay-time delay-time)
        fb-coefficient (comb-feedback delay-time decay-time)
        comb (+ in (* fb-coefficient delay))]
    (pipeset! feedback comb)
    comb))

(defugen combn
  "Comb filter with no interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2
   decay-time 1]
  (-comb in max-delay-time delay-time decay-time delayn))

(defugen combl
  "Comb filter with linear interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2
   decay-time 1]
  (-comb in max-delay-time delay-time decay-time delayl))

(defugen combc
  "Comb filter with cubic interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2
   decay-time 1]
  (-comb in max-delay-time delay-time decay-time delayc))

(docgroup "Delays")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defugen pan2
  "A two-channel, equal-power panner."
  [in 0
   pos 0
   level 1]
  (let [pos (clip pos)
        pi4 (* math.Pi 0.25)
        pi2 (* math.Pi 0.5)
        theta (+ (* pi4 pos) pi4)
        lamp (* level (sine (- pi2 theta)))
        ramp (* level (sine theta))]
    [(* in lamp)
     (* in ramp)]))

(defugen splay
  "Splay spreads an array of channels across the stereo
  field. Optional arguments are spread and center, and equal power
  levelCompensation. The formula for the stereo position is
  ((0 .. (n - 1)) * (2 / (n - 1)) - 1) * spread + center."
  [^:noexpand in 0
   spread 1
   level 1
   center 0
   ^:noexpand levelComp true]
  (let [n (count in)
        n (max 2 n)
        n1 (- n 1)
        positions (-> (range n)
                      (* (/ 2.0 n1))
                      (- 1)
                      (* spread)
                      (+ center))
        level (if levelComp
                (* level (math.Sqrt (/ 1.0 n)))
                level)]
    (sum (pan2 in positions level))))

(docgroup "Spatialization")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defugen wfold
  "Fold an input signal when it exceeds threshold low/high values.
  The signal is reflected across the low and high threshold values.
  Default low and high are -1 and 1."
  [in 0
   lo -1
   hi 1]
  (add-node! :wfold NewWaveFolder
             :in-edges {:in in
                        :lo lo
                        :hi hi}))

(defugen bitcrush
  "Bitcrush an input signal."
  [in 0
   bits 24
   rate 44100]
  (add-node! :bitcrush NewBitcrusher
             :in-edges {:in in
                        :rate rate
                        :bits bits}))

(defugen pitch-shift
  "Pitch shift an input signal using granular synthesis.
  
  The effect shifts the pitch of the input signal by the given ratio.
  A ratio of 2.0 shifts up an octave, 0.5 shifts down an octave.
  
  Uses overlapping grains with triangular windows (based on SuperCollider's
  PitchShift). The window-size parameter controls the grain size in seconds.
  Smaller windows (0.01-0.05) give lower latency but may have artifacts.
  Larger windows (0.05-0.2) give better quality but higher latency.
  
  The pitch-dispersion and time-dispersion parameters add randomness
  for chorus-like effects. Values from 0-1, where 0 is no dispersion."
  [in 0 "The input signal to pitch shift."
   pitch-ratio 1.0 "Pitch shift ratio (0-4.0). 1.0 = no shift, 2.0 = up octave, 0.5 = down octave."
   window-size 0.1 "Grain window size in seconds (minimum 3 samples)."
   pitch-dispersion 0.0 "Random pitch variation (0-1) for chorus effects."
   time-dispersion 0.0 "Random time variation (0-1) for smearing effects."]
  (add-node! :pitch-shift NewPitchShift
             :in-edges {:in in
                        :pitchRatio pitch-ratio
                        :windowSize window-size
                        :pitchDispersion pitch-dispersion
                        :timeDispersion time-dispersion}))

(docgroup "Distortion")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sampler

(defn add-sample-path!
  [& paths]
  (swap! *sample-file-paths* #(apply conj % paths)))

(def ^:private supported-sample-suffixes #{".wav" ".aiff" ".aif" ".flac" ".mp3"})

(defn search-samples
  [pat & pats]
  (let [matches (atom [])
        pats (cons pat pats)]
    (letfn [(walk [s dir-entry err]
              (when-not err
                (let [ext (path$filepath.Ext s)
                      [info err] (os.Stat s)]
                  (cond
                    err nil
                    (not (contains? supported-sample-suffixes ext)) nil
                    (.IsDir info) nil
                    (->> pats
                         (map name)
                         (map #(re-pattern %))
                         (map #(re-seq % s))
                         (every? identity)) (do (swap! matches conj s)
                                                nil)))))]
      (doseq [dir @*sample-file-paths*]
        (path$filepath.WalkDir dir walk))
      @matches)))

(defn find-sample
  "find-sample searches the directories given by the env var
  MUSCRAT_SAMPLE_PATH for a sample file whose base name matches the
  given keyword. If the sample is not found, an error is thrown.

  Supports the following file extensions: .wav, .aiff, .aif, .flac,"
  [pat & pats]
  (let [matches (apply search-samples pat pats)]
    (if (empty? matches)
      (throw (errors.New (str "sample not found matching " (cons pat pats))))
      (first matches))))

(defn load-sample
  "Load an audio sample from a file into a buffer (slice of float64s) or
  a slice of buffers for multi-channel audio. The buffer will be
  resampled from the source to the engine's sample rate (available in
  the SAMPLE-RATE var). See smp for an example of how to play a
  loaded sample."
  [pat-or-pats]
  (cond
    (keyword? pat-or-pats) (load-sample [pat-or-pats])
    (string? pat-or-pats) (LoadSample pat-or-pats)
    :else (load-sample (apply find-sample pat-or-pats))))

(defugen smp
  "Play a buffer (single-channel) or slice of buffers (multi-channel)."
  [^:noexpand buf-or-bufs nil
   rate 1
   trigger 1
   start-pos 0
   end-pos nil
   loop 0]
  (let [buf-or-bufs (if (or (keyword? buf-or-bufs)
                            (vector? buf-or-bufs)
                            (string? buf-or-bufs))
                      (load-sample buf-or-bufs)
                      buf-or-bufs)]
      (when-not (pos? (count buf-or-bufs))
        (throw (errors.New "smp requires a non-empty buffer or slice of buffers")))
    (let [bufs (if (#(or (number? %) (keyword? %)) (first buf-or-bufs))
                 [buf-or-bufs] ;; wrap single buffer in a vector
                 buf-or-bufs)
          end-pos (or end-pos (count (first bufs)))
          result (for [buf bufs]
                   (let [buf (if (keyword? buf)
                               (load-sample buf)
                               buf)]
                     (add-node! :smp NewSampler
                                :args [buf]
                                :in-edges {:trigger trigger
                                           :rate rate
                                           :start-pos start-pos
                                           :end-pos end-pos
                                           :loop (or loop 0)})))]
      (if (= 1 (count result))
        (first result)
        result))))

(docgroup "Sampler")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; I/O devices

(defugen sound-in
  []
  (add-node! :in NewInputDevice))

(defugen knob
  [^:noexpand name nil
   default 0
   min-value -1
   max-value 1
   step nil
   xform identity]
  (let [rng (- max-value min-value)
        step (or step (/ rng 100.0))
        ugen (add-node! :knob NewKnob :args [(str name) default min-value max-value step])]
    (xform ugen)))

(defn qwerty-in
  [name & {:keys [voices]}]
  (let [num-voices (or voices 1)
        opts [(WithVoices num-voices)]
        kb (apply NewSoftwareKeyboard name opts)]
    (map (fn [i]
           {:note (add-node! :swkb-note #(.Note %1 %2) :args [kb i])
            :onoff (add-node! :swkb-gate #(.Gate %1 %2) :args [kb i])})
         (range num-voices))))

(defn midi-in
  "Registers one or more input ugens that emit values from MIDI events.
  The 'name' argument is a user-defined name for the input, which is
  used to identify the input in the user interface. The 'typ' argument
  is the type of event to track, one of:

  - :note - returns a seq, one element per voice (see flags), of
     maps with elements for note on/off (1/0), midi note number, and
     velocity: {:onoff <node> :note <node> :velocity <node>}
  - :bend - returns a single ugen node for the pitch bend value
  - :cc - returns a single ugen node for a single controller change
    value.
  - :after-touch - returns a single ugen node for mono aftertouch

  # Voices

  The :note input type is monophonic by default, with a single set of
  ugens tracking the latest note. To enable polyphony, provide the
  number of voices with the :voices flag. Notes on the mapped channel
  will be automatically allocated across the returned voices.

  # Device Mappings

  Input ugens can be (re-)mapped in the user interface, but the
  default mapping can be controlled with the following flags:

  - :device-id - The MIDI device ID, or a seq of IDs. If a seq, the
    first matching device in the seq is used. Default is 0.
  - :device-name - A regular expression to match against the device
    name.
  - :channel - The channel to map to. Default is 0.
  - :controller - For :cc type, the controller ID to map to. Default
    is 0."
  [name typ & flags]
  (let [_ (if-not (contains? #{:note :bend :cc :after-touch} typ)
            (throw (fmt.Errorf "unsupported midi-in type: %s" typ)))
        flags (validate-flags flags {:voices 1
                                     :device-id 0
                                     :device-name nil
                                     :channel 0
                                     :controller 0
                                     :default 0})
        num-voices (:voices flags)
        opts [(WithVoices num-voices)
              (WithDeviceID (:device-id flags))
              (WithChannel (:channel flags))
              (WithController (:controller flags))
              (WithDefaultValue (:default flags))]
        opts (if-let [name (:device-name flags)]
               (conj opts (WithDeviceName name))
               opts)
        dev (apply NewMIDIInputDevice name opts)]
    (case typ
      :note     (map (fn [i] {:note (add-node! :midi-in-note #(.Note %1 %2) :args [dev i])
                              :onoff (add-node! :midi-in-gate  #(.Gate %1 %2) :args [dev i])})
                     (range num-voices))
      :cc (add-node! :midi-in-cc #(.Control %) :args [dev])
      (throw (fmt.Errorf "unsupported midi-in type: %s" typ))
      )))

(defugen wavout
  "Save the input to a 32-bit wav file (up to two channels) named by
  the :filename flag (default out.wav)."
  [^:noexpand chs 1
   filename "out.wav"]
  (let [chs (if (seq-or-vec? chs) chs [chs])
        _ (if (> (count chs) 2) (throw (str "wavout: too many channels supplied: " (count chs))))
        ch0 (first chs)
        ch1 (second chs)
        node (add-node! :wavout NewWavOut :args [filename]
                        :sink true
                        :in-edges {:$0 ch0})]
    (when-let [ch1 (second chs)]
      (add-edge! (as-node ch1) node "$1"))
    node))

(docgroup "I/O")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pattern utilities

(defn step
  "Cycle through a sequence of values on each trigger."
  [trig freqs & {:keys [sync]}]
  (let [node (add-node! :sequencer github.com$jfhamlin$muscrat$pkg$pattern.NewSequencer)
        trig (as-node trig)
        freqs (map as-node freqs)
        sync (if sync (as-node sync) nil)]
    (add-edge! trig node "trigger")
    (when sync (add-edge! sync node "sync"))
    (doseq-idx [[freq i] freqs]
               (add-edge! freq node (str \$ i)))
    node))

(defn choose
  "Pick randomly from a sequence of values, making a new choice on each
  trigger."
  [trig opts]
  (let [node (add-node! :choose github.com$jfhamlin$muscrat$pkg$pattern.NewChoose)
        trig (as-node trig)
        opts (map as-node opts)]
    (add-edge! trig node "trigger")
    (doseq-idx [[opt i] opts]
               (add-edge! opt node (str \$ i)))
    node))

(defugen latch
  "Holds input signal value when triggered. Latch will output 0 until it
  receives its first trigger."
  [in 0
   trigger 0]
  (add-node! :latch NewLatch :in-edges {:in in :trigger trigger}))

(defn euclid
  "Generate a Euclidean rhythm pattern. The Euclidean algorithm is a
  method for producing rhythms by evenly distributing a number of
  pulses over a number of steps. The algorithm is based on the
  greatest common divisor of the number of pulses and steps. The
  algorithm is generalized to allow for rotation of the pattern.

  For example, with 3 pulses and 8 steps (euclid 3 8), the Euclidean algorithm
  produces the pattern [1 0 0 1 0 0 1 0]."
  ([pulses steps rotation]
   (->> (euclid pulses steps)
        cycle
        (drop rotation)
        (take steps)
        vec))
  ([pulses steps]
   (let [pulses (int (math.Floor pulses))
         steps (int (math.Floor steps))]
     (when (> pulses steps)
       (throw (fmt.Errorf "euclid: pulses must be less than or equal to steps, got %d pulses and %d steps" pulses steps)))
     (cond (zero? pulses) (repeat steps 0)
           (== pulses steps) (repeat steps 1)
           :else (let [tbl (->> (range -1 steps)
                                (map #(* % pulses))
                                (map #(mod % steps)))]
                   (mapv #(if (> %1 %2) 1 0)
                         tbl (rest tbl)))))))

(defugen impulse-pattern
  [impulse 1 "The impulse signal to trigger the pattern."
   ^:noexpand pattern (euclid 3 8) "The pattern to trigger on the impulse signal."
   sync nil]
  (let [pat-seq (step impulse pattern :sync sync)]
    (* impulse pat-seq)))

(docgroup "Patterns")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tidal Cycles-like

(def ^{:dynamic true, :private true} *cps* nil)
(def ^:dynamic *tctick* nil)

(defn- tccoll?
  [coll]
  (and (coll? coll)
       (not (map? coll))
       (not (set? coll))))

(defn setcps!
  [cps]
  (pipeset! *cps* cps))

(defn tcpat
  [pattern]
  (cond
    (= pattern '_) 0
    (not (tccoll? pattern)) 1
    :else (let [sub-patterns (map tcpat pattern)
                sub-patterns (map #(if (tccoll? %) % [%]) sub-patterns)
                counts (map count sub-patterns)
                lcm-steps (reduce lcm counts)
                expanded (map (fn [pat cnt]
                                ;; pad each element with 0s to make
                                ;; the whole pat lcm-steps long
                                (let [rem (- lcm-steps cnt)
                                      rep (/ rem cnt)
                                      pad (repeat rep 0)]
                                  (map #(cons % pad) pat)))
                              sub-patterns counts)]
            (flatten expanded))))

(defn tcvals
  [value-pattern & {:keys [slow]}]
  (let [slow (long (or slow 1)) ;; must be integral
        cps (/ *cps* slow)
        tctick (pulse-div *tctick* slow slow)
        pattern (tcpat value-pattern)
        values (filter #(not= % '_) (flatten value-pattern))
        ticks (-> (impulse (* (count pattern) cps) :sync tctick)
                  (impulse-pattern pattern :sync tctick))
        value-steps (step ticks values :sync tctick)]
    [value-steps ticks]))

(defn- zero-rest
  "Replace 0s with '_ in a pattern."
  [pattern]
  (letfn [(replace [el]
            (if (tccoll? el)
              (zero-rest el)
              (if (and (number? el) (zero? el))
                '_
                el)))]
    (map replace pattern)))

(defn tctrig
  [trig-pattern & {:keys [slow]}]
  (let [slow (long (or slow 1)) ;; must be integral
        cps (/ *cps* slow)
        tctick (pulse-div *tctick* slow slow)
        trig-pattern (zero-rest trig-pattern) ;; replace 0s with '_
        pattern (tcpat trig-pattern)
        flat-pat (flatten trig-pattern)
        values (filter #(not= % '_) flat-pat)
        ticks (-> (impulse (* (count pattern) cps) :sync tctick)
                  (impulse-pattern pattern :sync tctick))]
    ticks))

(defmacro tcsmp
  [form]
  (letfn [(map-pat [fun pat]
            (if (not (coll? pat))
              (fun pat)
              (map (partial map-pat fun) pat)))]
    (let [syms (remove #{'_} (flatten form))
          sym-or-_ (fn [sym] [sym (map-pat #(if (= % sym) 1 '_) form)])
          sym-pats (into {} (map sym-or-_ syms))
          sym-lets (map (fn [[sym pat]]
                          `(let [tick# (tctrig '~pat)]
                             (smp ~(vec (strings.Split (str sym) ":"))
                                  :trigger tick#)))
                        sym-pats)]
      `(+ ~@sym-lets))))

(docgroup "Patterns - Tidal-like")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MIDI notes

(def ^:private note-names
  [["C" "B#"]
   ["C#" "Db"]
   ["D"]
   ["D#" "Eb"]
   ["E" "Fb"]
   ["F" "E#"]
   ["F#" "Gb"]
   ["G"]
   ["G#" "Ab"]
   ["A"]
   ["A#" "Bb"]
   ["B" "Cb"]])

(doseq [[note names] (map vector
                          (range 128)
                          (cycle note-names))]
  (let [octave-num (- (quot note 12) 1)]
    (doseq [name names]
      (eval
       `(def ~(symbol (str name octave-num)) ~note)))))

(docgroup "MIDI Notes")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Scales

(def ionian [0 2 4 5 7 9 11])
(def dorian [0 2 3 5 7 9 10])
(def phrygian [0 1 3 5 7 8 10])
(def lydian [0 2 4 6 7 9 11])
(def mixolydian [0 2 4 5 7 9 10])
(def aeolian [0 2 3 5 7 8 10])
(def locrian [0 1 3 5 6 8 10])

(def major ionian)
(def minor aeolian)

(def major-pentatonic [0 2 4 7 9])
(def minor-pentatonic [0 3 5 7 10])

(def blues [0 3 5 6 7 10])

(def harmonic-minor [0 2 3 5 7 8 11])
(def melodic-minor [0 2 3 5 7 9 11])

(def chromatic (range 12))

(defn scale
  "Generate the MIDI notes for a scale starting at the given root note."
  ([root intervals] (scale root intervals 1))
  ([root intervals num-octaves]
   (when (not (number? root))
     (throw (fmt.Errorf "root must be a MIDI note number, got %T" root)))
   (let [num-octaves (int num-octaves)
         notes-one-octave (map #(+ root %) intervals)
         octave-notes (for [octave (range num-octaves)]
                        (+ (* 12 octave) notes-one-octave))]
     (flatten octave-notes))))

(docgroup "Scales")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Synths

(defn- fm-op
  "Creates a simple FM 'operator' in the style of the Yamaha DX series."
  [freq envelope input & {:keys [feedback]}]
  (let [phase (phasor freq)
        feedback (or feedback 0)
        ;; log2 is used to scale the feedback amount
        feedback (log2 (+ feedback 1))
        has-feedback (or (not (number? feedback)) (> feedback 0))
        fb (if has-feedback (pipe) 0)
        osc (tri :phase (+ phase input fb)) ;; todo: sync with the trigger so that the phase is reset
        out (* osc envelope)]
    (if has-feedback (pipeset! fb (* feedback out)))
    out))

(defn fm-synth
  "Create a simple FM synthesizer with the given configuration. The
  configuration is a sequence of operator configurations, where each
  operator configuration is a vector of the form:

  [ratio amplitude envelope modulators feedback carrier]
  - ratio: the frequency ratio of the operator
  - amplitude: the amplitude of the operator
  - envelope: the ADSR envelope configuration for the operator
  - modulators: a sequence of indices of other operators to modulate
    this operator
  - feedback: the amount of feedback to apply to the operator
  - carrier: a boolean indicating whether this operator is a carrier
    (i.e. the output of the synth)

  The synth will sum the outputs of all carrier operators and return
  the result.

  For example, to create a simple FM synth with two operators, the
  first modulating the second:

  ```clojure
  (fm-synth [[1 1 [0.01 0.1 0.01 0.1] []  0 false]
             [2 1 [0.01 0.1 0.01 0.1] [0] 0 true]]
            gate freq)```"
  [op-conf gate freq]
  (let [ops (mapv (fn [[r a e m f c]]
                    (let [input (if-not (empty? m) (pipe) 0)
                          op (fm-op (* freq r)
                                    (* a (env-adsr gate e))
                                    input
                                    :feedback f)]
                      {:op op
                       :mods m
                       :input input
                       :carrier c}))
                  op-conf)]
    ;; wire up the modulators
    (doseq [{:keys [op mods input]} ops
            :when (not (empty? mods))]
      (let [in-sum (sum (map #(:op (nth ops %)) mods))]
        (pipeset! input in-sum)))
    (sum (->> ops
              (filter :carrier)
              (map :op)))))

(defugen supersaw
  "SuperSaw (Roland JP-8000 and JP-8080)

  Ported from https://gist.github.com/audionerd/fe50790b7601cba65ddd855caffb05ad"
  [freq 440
   mix 0.75
   detune 0.75]
  (letfn [(detune-curve [x]
            (+ (* 10028.7312891634 (pow x 11))
               (* -50818.8652045924 (pow x 10))
               (* 111363.4808729368 (pow x 9))
               (* -138150.6761080548 (pow x 8))
               (* 106649.6679158292 (pow x 7))
               (* -53046.9642751875 (pow x 6))
               (* 17019.9518580080 (pow x 5))
               (* -3425.0836591318 (pow x 4))
               (* 404.2703938388 (pow x 3))
               (* -24.1878824391 (pow x 2))
               (* 0.6717417634 x)
               0.0030115596))
          (center-gain [x] (+ (* -0.55366 x) 0.99785))
          (side-gain [x] (+ (* -0.73764 (pow x 2)) (* 1.2841 x) 0.044372))]
    (let [center (saw freq :iphase (math$rand.Float64))
          detune-factor (* freq (detune-curve detune))
          freqs [(+ freq (* detune-factor 0.11002313))
                 (+ freq (* detune-factor 0.06288439))
                 (+ freq (* detune-factor 0.01952356))
                 (+ freq (* detune-factor 0.01991221))
                 (+ freq (* detune-factor 0.06216538))
                 (+ freq (* detune-factor 0.10745242))]
          side (sum (map #(saw % :iphase (math$rand.Float64)) freqs))
          sig (+ (* center (center-gain mix)) (* side (side-gain mix)))]
      sig)))

(docgroup "Synth")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Hydra

(defn hydra
  "Create a new Hydra graph."
  ([graph] (hydra graph {}))
  ([graph mappings]
   (let [render-cmd (:render graph)
         sources (get graph :sources {})
         expr-map (go/make (go/map-of go/string go/any))
         src-map (go/make (go/map-of go/string go/any))]
     (letfn [(xform [expr]
               (cond
                 (keyword? expr) (if (contains? mappings expr)
                                   (name expr)
                                   (do (println "hydra warning: unbound reference" expr)
                                       0))
                 (symbol? expr) (xform (list "__lookup" (str expr)))
                 ;; translate to a slice of xformed exprs
                 (seq? expr) (let [xformed (atom (go/make (go/slice-of go/any)))]
                               ;; first element is the command
                               ;; add it as a string
                               (reset! xformed (go/append @xformed (str (first expr))))
                               ;; the rest of the elements are the arguments
                               ;; xform each one and add it to the slice
                               (doseq [e (rest expr)]
                                 (reset! xformed (go/append @xformed (xform e))))
                               @xformed)
                 ;; translate to a map of xformed keys and values
                 (map? expr) (let [xformed (go/make (go/map-of go/string go/any))]
                               (doseq [[k v] expr]
                                 (go/set-map-index xformed (name k) (xform v)))
                               xformed)
                 :else expr))]
       (go/set-map-index expr-map "render" (xform render-cmd))
       (doseq [[src expr] sources]
         (go/set-map-index src-map (name src) (xform expr)))
       (go/set-map-index expr-map "sources" src-map)
       (add-node! :hydra NewHydra
                  :args [expr-map (map name (keys mappings))]
                  :sink true
                  :in-edges mappings)))))

(docgroup "Hydra")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
