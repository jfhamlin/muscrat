(ns mrat.core
  (:import (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Generator
                                                    Sin
                                                    Saw
                                                    Tri
                                                    Pulse)
           (github.com$jfhamlin$muscrat$pkg$graph Node
                                                  WithLabel)))

(def ^:dynamic *graph* nil)

(defn- add-node
  [ug label]
  (.AddGeneratorNode *graph* ug (WithLabel (str label))))

(defn- add-edge
  [x y port] (.AddEdge *graph* (.ID x) (.ID y) port))

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(extend-protocol AsNode
  Node
  (as-node [n] n))

(extend-protocol AsNode
  float64
  (as-node [x] (add-node (NewConstant x) x)))

(extend-protocol AsNode
  int64
  (as-node [x] (add-node (NewConstant x) x)))

(defn play
  [& channels]
  (let [num-sinks (count (. *graph* sinks))
        ch-inds (map vector channels (range (count channels)))]
    (doseq [ch-ind ch-inds]
      (let [ch (first ch-ind)
            i (second ch-ind)
            gen (as-node ch)
            chan-id (+ num-sinks i)
            sink (.AddSinkNode *graph* (WithLabel (fmt.Sprintf "out%d" chan-id)))]
        (.AddEdge *graph* (. gen ID) (. sink ID) "w"))))) ;; TODO: "w" seems wrong

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

;; (defn- +-internal
;;   [& xs]
;;   (let [groups (group-by #(instance? Node %) xs)
;;         nums (get groups false ())
;;         ugens (get groups true ())
;;         num-sum (apply glojure.core/+ nums)]
;;     (if (empty? ugens)
;;       num-sum
;;       (let [sum-node (add-node (NewSum) "+")
;;             nodes (if (zero? num-sum) ugens
;;                       (conj ugens (add-node (NewConstant num-sum) num-sum)))]
;;         (doseq [[n i] (map vector nodes (range (count nodes)))]
;;           (add-edge n sum-node (str \$ i)))
;;         sum-node))))

;; (defn +
;;   "Return the sum of any combination of numbers or ugens.
;;   If any argument to + is a ugen, then the result of + is a ugen"
;;   ([] 0)
;;   ([x] x)
;;   ([x & more] (apply +-internal (cons x more))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(defn- handle-extra-gen-args
  [node args]
  (if (odd? (count args))
    (throw (fmt.Errorf "handle-extra-gen-args: odd number of args: %v" args))
    (doseq [[k v] (partition 2 args)]
      (let [gen (as-node v)
            param (k {:iphase "iphase"
                      :phase "phase"
                      :sync "sync"
                      :duty "dc"})]
        (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
        (.AddEdge *graph* (.ID gen) (.ID node) param)))))

(defmacro defwtosc
  [name wavtab]
  (let [fn-name (symbol (str name))]
  `(defn ~fn-name
     ([] (~fn-name 440))
     ([freq# & args#]
      (let [gen# (~'Generator (~wavtab 1024))
            label# (~'WithLabel ~(str name))
            osc-node# (.AddGeneratorNode *graph* gen# label#)
            freq-node# (as-node freq#)]
        (.AddEdge *graph* (.ID freq-node#) (.ID osc-node#) "w")
        (handle-extra-gen-args osc-node# args#)
        osc-node#)))))

(defwtosc sin Sin)
(defwtosc saw Saw)
(defwtosc tri Tri)
;; (defwtosc sqr Pulse) ;; TODO: add default duty cycle and label support

;; (def *sqr mrat.osc/sqr)
;; (def *pulse mrat.osc/pulse)
;; (def *noise mrat.osc/noise)
;; (def *pink-noise mrat.osc/pink-noise)
;; (def *phasor mrat.osc/phasor)
;; (def *sampler mrat.osc/sampler)

;; (def *freeverb mrat.effects/freeverb)
;; (def *delay mrat.effects/delay)
;; (def *clip mrat.effects/clip)
;; (def *trand mrat.math.rand/trand)
;; (def *env mrat.effects/env)
;; (def *lores mrat.effects/*lores)

;; (def rand mrat.math.rand/rand)

;; (defn remap
;;   "Remap a value from [min-in, max-in] to [min-out, max-out].
;;   If not provided, [min-in, max-in] defaults to [-1, 1]"
;;   ([x min max] (remap x -1 1 min max)
;;   ([x min-in max-in min max]
;;    (let [range-in (- max-in min-in)
;;          range-out (- max min)
;;          x (- x min-in)]
;;      (+ min (/ (* x range-out) range-in)))))

;; (defn decibels [db] (pow 10 (/ db 20)))

;; (def *mixer
;;   (fn [& args]
;;     (let ((mixerArgs args))
;;       (let ((weightSum (reduce + 0
;;                                (map-idx (fn [val idx] (if (even? idx) val 0)) mixerArgs))))
;;         (sum (map (fn [idx] (let ((weight (nth mixerArgs (* 2 idx)))
;;                                   (chan   (nth mixerArgs (+ (* 2 idx) 1))))
;;                               (* (/ weight weightSum) chan)))
;;                   (range 0 (/ (length mixerArgs) 2))))))))

;; ;;; TODO: move to a library for music theory.
;; (defn cents [x] (pow 2 (/ x 1200)))
;; (defn semitones [x] (pow 2 (/ x 12)))
;; (defn octaves [x] (pow 2 x))
