(ns mrat.core
  (:import (github.com$glojurelang$glojure$pkg$lang *Ratio *BigInt)
           (github.com$jfhamlin$muscrat$pkg$graph Node
                                                  WithLabel
                                                  WithSink)
           (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum
                                                 NewProduct
                                                 NewFMA
                                                 NewFMAStatic
                                                 NewQuotient
                                                 NewAbs
                                                 NewExp
                                                 NewPow
                                                 NewCopySign
                                                 NewFreqRatio
                                                 NewMIDIFreq
                                                 NewImpulse
                                                 SimpleUGenFunc
                                                 WithAdd
                                                 WithMul
                                                 WithInterp
                                                 WithDefaultDutyCycle
                                                 InterpNone
                                                 InterpLinear
                                                 InterpCubic)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Table)
           (github.com$jfhamlin$muscrat$pkg$osc NewSine
                                                NewSaw
                                                NewTri
                                                NewPulse
                                                NewPhasor
                                                NewLFSaw
                                                NewLFPulse)
           (github.com$jfhamlin$muscrat$pkg$stochastic NewNoise
                                                       NewNoiseQuad
                                                       NewPinkNoise)
           (github.com$jfhamlin$muscrat$pkg$mod NewEnvelope
                                                WithReleaseNode
                                                WithInterpolation)
           (github.com$jfhamlin$muscrat$pkg$effects NewAmplitude
                                                    NewFreeverb
                                                    NewLimiter
                                                    NewLowpassFilter
                                                    NewRLPF
                                                    NewRHPF
                                                    NewBPF
                                                    NewLoShelf
                                                    NewHiShelf
                                                    NewPeakEQ
                                                    NewDelay
                                                    NewTapeDelay
                                                    NewWaveFolder
                                                    NewClip)
           (github.com$jfhamlin$muscrat$pkg$sampler NewSampler
                                                    LoadSample)
           (github.com$jfhamlin$muscrat$pkg$aio NewInputDevice
                                                NewSoftwareKeyboard
                                                NewMIDIInputDevice
                                                WithVoices
                                                WithDeviceID
                                                WithDeviceName
                                                WithChannel
                                                WithController
                                                WithDefaultValue
                                                NewWavOut)
           (github.com$jfhamlin$freeverb-go NewRevModel)))

(defmacro doseq-idx
  [[locals seq-expr] & body]
  `(let [s# ~seq-expr]
     (doseq [~locals (map vector s# (range (count s#)))]
       ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Graph

(def ^:dynamic *graph* nil)

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(declare add-edge!)

(defn add-node!
  [ug label & {:keys [sink in-edges]}]
  (let [node (if sink
               (.AddGeneratorNode *graph* ug (WithLabel (str label)) (WithSink))
               (.AddGeneratorNode *graph* ug (WithLabel (str label))))]
    (doseq [[port val] in-edges]
      (add-edge! (as-node val) node (name port)))
    node))

(defn add-edge!
  [x y port] (.AddEdge *graph* (.ID x) (.ID y) port))

(extend-protocol AsNode
  Node
  (as-node [n] n))

(extend-protocol AsNode
  go/float64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  go/int64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  *BigInt
  (as-node [x] (add-node! (NewConstant (double x)) x)))

(extend-protocol AsNode
  *Ratio
  (as-node [x] (add-node! (NewConstant (double x)) x)))

(defn play
  [channels]
  (let [channels (if-not (coll? channels) [channels channels] channels)
        channels (if (= (count channels) 0) [0 0] channels)
        channels (if (= (count channels) 1) [(first channels) (first channels)] channels)
        num-sinks (count (. *graph* outputs))
        ch-inds (map vector channels (range (count channels)))]
    (doseq [[ch i] ch-inds]
      (let [gen (as-node ch)
            chan-id (+ num-sinks i)
            sink (.AddOutNode *graph* (WithLabel (fmt.Sprintf "out%d" chan-id)))]
        (add-edge! gen sink "w"))))) ;; TODO: "w" seems wrong

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

(defn pow
  "Returns b^e. If b or e are nodes, creates a new node that computes b^e. Else,
  returns the result of b^e directly."
  [b e]
  (if (some (partial instance? Node) [b e])
    (let [n (add-node! (NewPow) "pow")]
      (add-edge! (as-node b) n "base")
      (add-edge! (as-node e) n "exp")
      n)
    (math.Pow b e)))

(defn sine
  "Returns sin(theta). If theta is a node, creates a new node that
  computes sin(theta). Else, returns the result of sin(theta)
  directly."
  [theta]
  (if-not (instance? Node theta)
    (math.Sin theta)
    (let [n (add-node! (github.com$jfhamlin$muscrat$pkg$ugen.NewSine) "sine")]
      (add-edge! theta n "in")
      n)))

(defn abs
  "Returns the absolute value of x. If x is a node, creates a new node
  that computes the absolute value of x. Else, returns the absolute
  value of x directly."
  [x]
  (if (instance? Node x)
    (let [n (add-node! (NewAbs) "abs")]
      (add-edge! x n "in")
      n)
    (math.Abs x)))

(defn exp
  "Returns e^x. If x is a node, creates a new node that computes e^x.
  Else, returns e^x directly."
  [x]
  (if (instance? Node x)
    (let [n (add-node! (NewExp) "exp")]
      (add-edge! x n "in")
      n)
    (math.Exp x)))

(defn copy-sign
  "Returns x with the sign of s. If x or s are nodes, creates a new node
  that computes x with the sign of s. Else, returns x with the sign of
  s directly."
  [x s]
  (if (or (instance? Node x) (instance? Node s))
    (let [n (add-node! (NewCopySign) "copy-sign")]
      (add-edge! (as-node x) n "in")
      (add-edge! (as-node s) n "sign")
      n)
    (math.Copysign x s)))

(defn- freq-ratio
  [x kind]
  (let [n (add-node! (NewFreqRatio kind) kind)]
    (add-edge! x n "in")
    n))

(defn decibels
  "Return the amplitude ratio corresponding to the given decibel value."
  [db]
  (if (instance? Node db)
    (freq-ratio db "decibels")
    (pow 10 (/ db 20.0))))

(defn cents
  "Return the frequency ratio corresponding to the given number of
  cents."
  [x]
  (if (instance? Node x)
    (let [cnt (add-node! (NewFreqRatio "cents") "cents")]
      (add-edge! x cnt "in")
      cnt)
    (pow 2 (/ x 1200.0))))

(defn semitones
  "Return the frequency ratio corresponding to the given number of
  semitones."
  [x]
  (if (instance? Node x)
    (let [stn (add-node! (NewFreqRatio "semitones") "semitones")]
      (add-edge! x stn "in")
      stn)
    (pow 2 (/ x 12.0))))

(defn octaves
  "Return the frequency ratio corresponding to the given number of
  octaves."
  [x]
  (if (instance? Node x)
    (let [oct (add-node! (NewFreqRatio "octaves") "octaves")]
      (add-edge! x oct "in")
      oct)
    (pow 2 x)))

(defn midifreq
  "Return the frequency corresponding to the given MIDI note number."
  [note]
  (if (instance? Node note)
    (let [mf (add-node! (NewMIDIFreq) "midifreq")]
      (add-edge! note mf "in")
      mf)
    (* 440.0 (pow 2 (/ (- note 69.0) 12.0)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper for custom sample generators

(defn ugen-fn
  "Returns a UGenFunc that wraps the given function. The function should
  take a map of configuration parameters and an output buffer, and
  write samples to the output buffer."
  [f]
  (let [wrapped (fn [cfg out]
                  (f {:sample-rate-hz (.SampleRateHz cfg)
                      :input-samples (.InputSamples cfg)}
                     out))]
    (SimpleUGenFunc wrapped)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

(defn- +-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-sum (apply glojure.core/+ nums)]
    (if (empty? ugens)
      num-sum
      (let [sum-node (add-node! (NewSum) "+")
            nodes (if (zero? num-sum)
                    ugens
                    (conj ugens (add-node! (NewConstant num-sum) num-sum)))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n sum-node (str \$ i)))
        sum-node))))

(defn +
  "Return the sum of any combination of numbers or ugens.
  If any argument to + is a node, then the result of + is a node.  If
  any argument to + is a collection, then the result is a collection
  whose length is the length of the longest collection (max-len) and
  where the elements of each argument are added pairwise. Any
  non-collections are duplicated to max-len, and any collections
  shorter than max-len are cycled up to max-len."
  ([] 0)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map + colls))
       (apply +-internal args)))))

(declare *)

(defn -
  "Return the difference of any combination of numbers or ugens.
  If any argument to - is a node, then the result of - is a node"
  ([] 0)
  ([x] (* -1 x))
  ([x & more] (+ x (apply + (map #(* -1 %) more)))))

(defn- *-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-prod (apply glojure.core/* nums)]
    (if (empty? ugens)
      num-prod
      (let [prod-node (add-node! (NewProduct) "*")
            nodes (conj ugens (add-node! (NewConstant (double num-prod)) num-prod))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n prod-node (str \$ i)))
        prod-node))))

(defn *
  "Return the product of any combination of numbers or ugens.
  If any argument to * is a node, then the result of * is a node."
  ([] 1)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map * colls))
       (apply *-internal args)))))

(defn- div-internal
  [& xs]
  (if (every? #(not (instance? Node %)) xs)
    (apply glojure.core// xs)
    (let [quot-node (add-node! (NewQuotient) "/")
          nodes (map as-node xs)]
      (doseq [[n i] (map vector nodes (range (count nodes)))]
        (add-edge! n quot-node (str \$ i)))
      quot-node)))

(defn /
  "Return the quotient of any combination of numbers or ugens.
  If any argument to / is a node, then the result of / is a node."
  ([x] (/ 1 x))
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map / colls))
       (apply div-internal args)))))

(defn sum
  [coll] (apply + coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; macros

(defn fma
  [in mul add]
  (if (and (every? number? [mul add])
           (== mul 1)
           (== add 0))
      in
      (let [node (if (every? number? [mul add])
                   (add-node! (NewFMAStatic mul add) "fma")
                   (let [n (add-node! (NewFMA) "fma")]
                     (add-edge! (as-node mul) n "mul")
                     (add-edge! (as-node add) n "add")
                     n))]
        (add-edge! (as-node in) node "in")
        node)))

(defmacro defugen
  "Defines a new generator node constructor with semantics similar to defn,
  but with specific constraints and enhancements for argument
  handling.  This macro allows only a single arity and requires the
  argument vector to be defined in pairs. Each pair consists of an
  argument name followed by its default value. When the resulting
  function is called, all parameters are optional; unprovided
  parameters default to their specified values. Additionally, callers
  can provide arguments out of their original order or skip certain
  arguments by using keyword-value pairs, where the keyword matches
  the argument name. This feature offers flexibility in how arguments
  are passed to the function, allowing for more dynamic and adaptable
  function calls."
  [name & decl]
  (let [[doc args & body] (if (string? (first decl))
                            decl
                            (cons "" decl))
        arg-pairs (partition 2 args)
        arg-names (mapv (comp keyword first) arg-pairs)
        defaults (into {} (map (fn [[k v]] [(keyword k) v]) arg-pairs))
        allowed-keys (merge (set (keys defaults)) :mul :add)
        assignments-sym (gensym "assignments")]
    `(defn ~name ~doc [& args#]
       (let [defaults# ~defaults
             ~assignments-sym (loop [assignments# {}
                                     arg-names# ~arg-names
                                     args# args#]
                                (if (or (empty? args#)
                                        (contains? ~allowed-keys (first args#)))
                                  (merge assignments# (apply hash-map args#))
                                  (if (empty? arg-names#)
                                    (throw (errors.New "too many positional arguments"))
                                    (recur (assoc assignments# (first arg-names#) (first args#))
                                           (rest arg-names#)
                                           (rest args#)))))
             ~assignments-sym (merge defaults# ~assignments-sym)
             ~@(mapcat (fn [[arg-name default]]
                         `(~arg-name (get ~assignments-sym ~(keyword arg-name))))
                       arg-pairs)
             ugen# (do ~@body)]
         (let [mul# (get ~assignments-sym :mul 1)
               add# (get ~assignments-sym :add 0)]
           (fma ugen# mul# add#))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(def default-freq 440)

(defn- validate-flags
  [flags defaults]
  (if (odd? (count flags))
    (throw (apply str "odd number of flag args: " (interpose \, flags))))
  (let [m (reduce #(apply assoc %1 %2) {} (partition 2 flags))
        unsupported (seq (remove (set (keys defaults)) (keys m)))]
    (if unsupported (throw (apply str "unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (merge defaults m)))

(defn- handle-extra-gen-args
  [node args-map]
  (doseq [[k v] args-map]
    (let [gen (as-node v)
          param (k {:iphase "iphase"
                    :phase "phase"
                    :sync "sync"
                    :duty "dc"})]
      (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
      (add-edge! gen node param))))

(defmacro defosc
  [name ctor & {:keys [default-duty] :or {default-duty 1}}]
  (let [opt-args '[duty iphase sync phase]]
    `(defugen ~name
       [~'freq default-freq
        ~@(mapcat #(vector % nil) opt-args)]
       (let [wt-opts# [(~'WithDefaultDutyCycle ~default-duty)]
             gen# (apply ~ctor wt-opts#)
             label# (~'WithLabel ~(str name))
             osc-node# (add-node! gen# label#)
             freq-node# (as-node ~'freq)
             extra-args# ~(mapv #(vector (keyword %) %) opt-args)
             extra-args# (into {} (remove (comp nil? second) extra-args#))]
         (add-edge! freq-node# osc-node# "w")
         (handle-extra-gen-args osc-node# extra-args#)
         osc-node#))))

(defosc sin NewSine)
(defosc saw NewSaw)
(defosc tri NewTri)
(defosc phasor NewPhasor)

(defosc pulse NewPulse :default-duty 0.5)
(defosc sqr NewPulse :default-duty 0.5)

(defosc lfsaw NewLFSaw)
(defosc lfpulse NewLFPulse :default-duty 0.5)
(defosc lfsqr NewLFPulse :default-duty 0.5)

(defugen impulse
  [freq default-freq
   iphase nil]
  (let [iphase (if iphase (as-node iphase))
        freq-node (as-node freq)
        node (add-node! (NewImpulse) "impulse")]
    (if iphase (add-edge! iphase node "iphase"))
    (add-edge! freq-node node "w")
    node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Noise

;; todo: add/mul flags

(defugen noise
  "Generates random values between -1 and 1 at the given frequency.
  If frequency is zero or not provided, generates white
  noise."
  [freq 0]
  (add-node! (NewNoise) "noise" :in-edges {:w freq}))

(defugen pink-noise
  []
  (add-node! (NewPinkNoise) "pink-noise"))

(defugen noise-quad
  "Generates quadratically-interpolated random values between -1 and 1
  at the given frequency. If frequency is zero or not provided,
  generates at 500 hz."
  [freq 500]
  (add-node! (NewNoiseQuad) "noise-quad" :in-edges {:w freq}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modulators

(defn env
  [gate levels times & flags]
  (let [flags (validate-flags flags {:interp :lin, :release-node -1})
        trigger (as-node gate)
        levels (map as-node levels)
        times (map as-node times)]
    (if (not= (count levels) (inc (count times)))
      (throw (str "env expects the number of levels to be one more than the number of times, got " (count levels) " levels and " (count times) " times.")))
    (let [env-node (add-node! (NewEnvelope
                               (WithInterpolation (subs (str (:interp flags)) 1))
                               (WithReleaseNode (:release-node flags)))
                              "envelope")]
      (add-edge! trigger env-node "trigger")
      (doseq [[n i] (map vector levels (range (count levels)))]
        (add-edge! n env-node (str "level$" i)))
      (doseq [[n i] (map vector times (range (count times)))]
        (add-edge! n env-node (str "time$" i)))
      env-node)))

(defn env-asr
  [gate [a s r]]
  (env gate [0 s 0] [a r] :release-node 1))

(defn env-adsr
  [gate [a d s r]]
  (env gate [0 1 s 0] [a d r] :release-node 2))

(defn env-perc
  [gate [a d]]
  (env gate [0 1 0] [a d]))

(defn line
  "Generates a line from the start value to the end value over the given
  duration."
  [start end dur & {:keys [mul add]}]
  (let [sig (env 1 [start end] [dur] :interp :lin)
        sig (if mul (* mul sig) sig)
        sig (if add (+ sig add) sig)]
    sig))

(defn xline
  "Generates an exponential curve from the start value to the end
  value. Both the start and end values must be non-zero and have the
  same sign."
  [start end dur & {:keys [mul add]}]
  (let [sig (env 1 [start end] [dur] :interp :exp)
        sig (if mul (* mul sig) sig)
        sig (if add (+ sig add) sig)]
    sig))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Filters and Effects

(defn amplitude
  ([in] (amplitude in 0.01 0.01))
  ([in attack-time release-time & {:keys [mul add]}]
   (let [opts []
         opts (if mul (conj opts (WithMul mul)) opts)
         opts (if add (conj opts (WithAdd add)) opts)
         node (add-node! (apply NewAmplitude attack-time release-time opts) "amplitude")]
     (add-edge! (as-node in) node "in")
     node)))

(defn limiter
  "Limits the input amplitude to the given level. Limiter will not
  overshoot, but it needs to look ahead in the audio. Thus there is a
  delay equal to twice the value of the dur parameter.

  Limiter is completely transparent for an in range signal.

  in - The signal to be processed.
  level - The peak output amplitude level to which to normalize the input.
  dur - aka lookAheadTime. The buffer delay time. Shorter times will
        produce smaller delays and quicker transient response times, but may
        introduce amplitude modulation artifacts."
  ([in] (limiter in 1.0))
  ([in level] (limiter in level 0.01))
  ([in level dur]
   (let [node (add-node! (NewLimiter dur) "limiter")]
     (add-edge! (as-node in) node "in")
     (add-edge! (as-node level) node "amp")
     node)))

(defn pipe
  "Create a pipe, which copies the input to the output. The input may be
  set with pipeset!. This is useful for creating feedback loops."
  []
  (let [f (fn [cfg out]
            (when-let [in (get (:input-samples cfg) "in")]
              (go/copy out in)))]
    (add-node! (ugen-fn f) "pipe")))

(defn pipeset!
  "Set the input of a pipe."
  [p in]
  (add-edge! (as-node in) p "in"))

(defn- freeverb-gen
  [& opts]
  (let [wet (get opts :wet 0.5)
        damp (get opts :damp 0.5)
        width (get opts :width 1.0)]
    (NewFreeverb
     (doto (NewRevModel)
       (.SetWet wet)
       (.SetDamp damp)
       (.SetWidth width)))))

(defn freeverb
  "A reverb effect. Options are:
  :dry - the amount of dry signal to mix in (0-1)
  :wet - the amount of wet signal to mix in (0-1)
  :room-size - the size of the room (0-1)
  :damp - the damping factor (0-1)"
  [node & opts]
  (let [opts (apply hash-map opts)
        supported #{:dry :wet :room-size :damp :width}
        unsupported (seq (remove supported (keys opts)))
        _ (if unsupported (throw (apply str "freeverb: unsupported option(s) supplied: "
                                        (interpose \, unsupported))))
        fv-node (add-node! (apply freeverb-gen opts) "freeverb")
        rs-node (as-node (get opts :room-size 0.5))
        dry-node (as-node (get opts :dry 0.5))]
    (add-edge! node fv-node "$0")
    (add-edge! rs-node fv-node "room-size")
    (add-edge! dry-node fv-node "dry")
    fv-node))

(defn lores
  "A simple lowpass filter with cutoff and resonance, modeled after the
  Max/MSP lores~ object."
  [n cutoff res]
  (let [n (as-node n)
        cutoff (as-node cutoff)
        res (as-node res)
        lpf (add-node! (NewLowpassFilter) "lores")]
    (add-edge! n lpf "in")
    (add-edge! cutoff lpf "cutoff")
    (add-edge! res lpf "resonance")
    lpf))

(defn rlpf
  "A resonant low-pass filter."
  [in freq rq & {:keys [mul add]}]
  (let [in (as-node in)
        freq (as-node freq)
        rq (as-node rq)
        opts [(WithMul (or mul 1.0)) (WithAdd (or add 0.0))]
        node (add-node! (apply NewRLPF opts) "rlpf")]
    (add-edge! in node "in")
    (add-edge! freq node "freq")
    (add-edge! rq node "reson")
    node))

(defn rhpf
  "A resonant high-pass filter."
  [in freq rq & {:keys [mul add]}]
  (let [in (as-node in)
        freq (as-node freq)
        rq (as-node rq)
        opts [(WithMul (or mul 1.0)) (WithAdd (or add 0.0))]
        node (add-node! (apply NewRHPF opts) "rhpf")]
    (add-edge! in node "in")
    (add-edge! freq node "freq")
    (add-edge! rq node "reson")
    node))

(defn bpf
  "A simple bandpass filter with center frequency and bandwidth.
   n - the input signal
   freq - the center frequency in hertz
   bw - the width of the filter, as a coefficient bandwidth/freq"
  [n freq bw]
  (let [n (as-node n)
        freq (as-node freq)
        bw (as-node bw)
        filter (add-node! (NewBPF) "bpf")]
    (add-edge! n filter "in")
    (add-edge! freq filter "w")
    (add-edge! bw filter "bw")
    filter))

(defn loshelf
  ([in] (loshelf in 1200.0))
  ([in freq] (loshelf in freq 1.0))
  ([in freq rs] (loshelf in freq rs 0))
  ([in freq rs db & {:keys [mul add]}]
   (let [in (as-node in)
         freq (as-node freq)
         rs (as-node rs)
         db (as-node db)
         mul (or mul 1.0)
         add (or add 0.0)
         opts [(WithMul mul) (WithAdd add)]
         node (add-node! (apply NewLoShelf opts) "loshelf")]
     (add-edge! in node "in")
     (add-edge! freq node "w")
     (add-edge! rs node "rs")
     (add-edge! db node "db")
     node)))

(defn hishelf
  ([in] (hishelf in 1200.0))
  ([in freq] (hishelf in freq 1.0))
  ([in freq rs] (hishelf in freq rs 0))
  ([in freq rs db & {:keys [mul add]}]
   (let [in (as-node in)
         freq (as-node freq)
         rs (as-node rs)
         db (as-node db)
         mul (or mul 1.0)
         add (or add 0.0)
         opts [(WithMul mul) (WithAdd add)]
         node (add-node! (apply NewHiShelf opts) "hishelf")]
     (add-edge! in node "in")
     (add-edge! freq node "w")
     (add-edge! rs node "rs")
     (add-edge! db node "db")
     node)))

(defn peakeq
  ([in] (peakeq in 1200.0))
  ([in freq] (peakeq in freq 1.0))
  ([in freq rq] (peakeq in freq rq 0))
  ([in freq rq db & {:keys [mul add]}]
   (let [in (as-node in)
         freq (as-node freq)
         rq (as-node rq)
         db (as-node db)
         mul (or mul 1.0)
         add (or add 0.0)
         opts [(WithMul mul) (WithAdd add)]
         node (add-node! (apply NewPeakEQ opts) "peakeq")]
     (add-edge! in node "in")
     (add-edge! freq node "w")
     (add-edge! rq node "rq")
     (add-edge! db node "db")
     node)))

(defn- -delay
  [in max-delay-time delay-time interp-opt & flags]
  (let [flags (validate-flags flags {:mul 1.0 :add 0.0})
        opts [(github.com$jfhamlin$muscrat$pkg$ugen.WithMul (:mul flags))
              (github.com$jfhamlin$muscrat$pkg$ugen.WithAdd (:add flags))]
        delay (add-node! (apply NewDelay max-delay-time interp-opt opts) "delay")]
    (add-edge! (as-node in) delay "in")
    (add-edge! (as-node delay-time) delay "delay")
    delay))

(defn delayn
  "Delay line with no interpolation."
  [in max-delay-time delay-time & flags]
  (apply -delay in max-delay-time delay-time (WithInterp InterpNone) flags))

(defn delayl
  "Delay line with linear interpolation."
  [in max-delay-time delay-time & flags]
  (apply -delay in max-delay-time delay-time (WithInterp InterpLinear) flags))

(defn delayc
  "Delay line with cubic interpolation."
  [in max-delay-time delay-time & flags]
  (apply -delay in max-delay-time delay-time (WithInterp InterpCubic) flags))

(defn tape-delayl
  "Tape delay line with linear interpolation. This generator simulates
  a tape read head such that changes to the delay value are not
  instantaneous - the 'tape' is sped up or slowed down to reach the
  target delay time."
  [n delay-time]
  (let [delay (add-node! (NewTapeDelay) "tape-delay")]
    (add-edge! (as-node n) delay "$0")
    (add-edge! (as-node delay-time) delay "delay")
    delay))

(defn- comb-feedback
  [delay-time decay-time]
  (if (or (and (not (instance? Node delay-time)) (zero? delay-time))
          (and (not (instance? Node decay-time)) (zero? decay-time)))
    0.0
    (let [abs-decay (abs decay-time)
          power (/ (* (math.Log 0.001) delay-time) abs-decay)
          absret (exp power)]
      (copy-sign absret decay-time))))

(defn- -comb
  [in max-delay-time delay-time decay-time delay-fn & flags]
  (let [flags (validate-flags flags {:mul 1.0 :add 0.0})
        opts [(github.com$jfhamlin$muscrat$pkg$ugen.WithMul (:mul flags))
              (github.com$jfhamlin$muscrat$pkg$ugen.WithAdd (:add flags))]
        feedback (pipe)
        delay (delay-fn feedback max-delay-time delay-time)
        fb-coefficient (comb-feedback delay-time decay-time)
        comb (+ in (* fb-coefficient delay))]
    (pipeset! feedback comb)
    comb))

(defn combn
  "Comb filter with no interpolation."
  [in max-delay-time delay-time decay-time & flags]
  (apply -comb in max-delay-time delay-time decay-time delayn flags))

(defn combl
  "Comb filter with linear interpolation."
  [in max-delay-time delay-time decay-time & flags]
  (apply -comb in max-delay-time delay-time decay-time delayl flags))

(defn combc
  "Comb filter with cubic interpolation."
  [in max-delay-time delay-time decay-time & flags]
  (apply -comb in max-delay-time delay-time decay-time delayc flags))

(defn clip
  "Clip an input signal when it exceeds threshold low/high values."
  ([in] (clip in -1 1))
  ([in lo hi]
   (if (some (partial instance? Node) [in lo hi])
     (let [c (add-node! (NewClip) "clip")
           [in lo hi] (map as-node [in lo hi])]
       (add-edge! in c "in")
       (add-edge! lo c "lo")
       (add-edge! hi c "hi")
       c)
     (-> in
         (max lo)
         (min hi)))))

(defn pan2
  ([in pos] (pan2 in pos 1))
  ([in pos level]
   (let [pos (clip pos)
         pi4 (* math.Pi 0.25)
         pi2 (* math.Pi 0.5)
         theta (+ (* pi4 pos) pi4)
         lamp (* level (sine (- pi2 theta)))
         ramp (* level (sine theta))]
     [(* in lamp)
      (* in ramp)])))

(defn wfold
  "Fold an input signal when it exceeds threshold low/high values.
  The signal is reflected across the low and high threshold values.
  Default low and high are -1 and 1."
  ([in] (wfold in -1 1))
  ([in lo hi]
   (let [wf (add-node! (NewWaveFolder) "wfold")
         [in lo hi] (map as-node [in lo hi])]
     (add-edge! in wf "in")
     (add-edge! lo wf "lo")
     (add-edge! hi wf "hi")
     wf)))

(defn bitcrush
  "Bitcrush an input signal."
  ([in bits] (bitcrush in bits 44100.0))
  ([in bits rate]
   (let [rate (as-node rate)
         bits (as-node bits)
         out (add-node! (github.com$jfhamlin$muscrat$pkg$effects.NewBitcrusher) "bitcrush")]
     (add-edge! in out "in")
     (add-edge! rate out "rate")
     (add-edge! bits out "bits")
     out)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sampler

(defn load-sample
  [path] (LoadSample path))

(defn sampler
  ([sample & flags]
   (let [[gate flags] (if-not (keyword? (first flags))
                        [(first flags) (rest flags)]
                        [nil flags])
         [rate flags] (if-not (keyword? (first flags))
                        [(first flags) (rest flags)]
                        [nil flags])
         flags (validate-flags flags {:loop false})
         node (add-node! (NewSampler (seq sample) (:loop flags)) "sampler")]
     (if gate
       (add-edge! (as-node gate) node "trigger"))
     (if (and rate (not= rate 1.0))
       (add-edge! (as-node rate) node "rate"))
     node)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; I/O devices

(defn sound-in
  []
  (add-node! (NewInputDevice) "in"))

(defn qwerty-in
  [name & {:keys [voices]}]
  (let [num-voices (or voices 1)
        opts [(WithVoices num-voices)]
        kb (apply NewSoftwareKeyboard name opts)]
    (map (fn [i]
           {:note (add-node! (.Note kb i) (str "note-" i))
            :onoff (add-node! (.Gate kb i) (str "gate-" i))})
         (range num-voices))))

(defn midi-in
  "Registers one or more input ugens that emit values from MIDI events.
  The 'name' argument is a user-defined name for the input, which is
  used to identify the input in the user interface. The 'typ' argument
  is the type of event to track, one of:

  - :note - returns a seq, one element per voice (see flags), of
     maps with elements for note on/off (1/0), midi note number, and
     velocity: {:onoff <node> :note <node> :velocity <node>}
  - :bend - returns a single ugen node for the pitch bend value
  - :cc - returns a single ugen node for a single controller change
    value.
  - :after-touch - returns a single ugen node for mono aftertouch

  # Voices

  The :note input type is monophonic by default, with a single set of
  ugens tracking the latest note. To enable polyphony, provide the
  number of voices with the :voices flag. Notes on the mapped channel
  will be automatically allocated across the returned voices.

  # Device Mappings

  Input ugens can be (re-)mapped in the user interface, but the
  default mapping can be controlled with the following flags:

  - :device-id - The MIDI device ID, or a seq of IDs. If a seq, the
    first matching device in the seq is used. Default is 0.
  - :device-name - A regular expression to match against the device
    name.
  - :channel - The channel to map to. Default is 0.
  - :controller - For :cc type, the controller ID to map to. Default
    is 0."
  [name typ & flags]
  (let [_ (if-not (contains? #{:note :bend :cc :after-touch} typ)
            (throw (fmt.Errorf "unsupported midi-in type: %s" typ)))
        flags (validate-flags flags {:voices 1
                                     :device-id 0
                                     :device-name nil
                                     :channel 0
                                     :controller 0
                                     :default 0})
        num-voices (:voices flags)
        opts [(WithVoices num-voices)
              (WithDeviceID (:device-id flags))
              (WithChannel (:channel flags))
              (WithController (:controller flags))
              (WithDefaultValue (:default flags))]
        opts (if-let [name (:device-name flags)]
               (conj opts (WithDeviceName name))
               opts)
        dev (apply NewMIDIInputDevice name opts)]
    (case typ
      :note     (map #(do {:note (add-node! (.Note dev %) "midi-note")
                           :onoff (add-node! (.Gate dev %) "midi-gate")})
                     (range num-voices))
      :cc (add-node! (.Control dev) "midi-cc")
      (throw (fmt.Errorf "unsupported midi-in type: %s" typ))
      )))

(defn wavout
  "Save the input to a 32-bit wav file (up to two channels) named by
  the :filename flag (default out.wav)."
  [chs & flags]
  (let [chs (if (coll? chs) chs [chs])
        flags (validate-flags flags {:filename "out.wav"})
        _ (if (> (count chs) 2) (throw (str "wavout: too many channels supplied: " (count chs))))
        ch0 (as-node (first chs))
        ch1 (second chs)
        n (add-node! (NewWavOut (:filename flags)) "wavout" :sink true)]
    (add-edge! ch0 n "$0")
    (when ch1
      (add-edge! ch1 n "$1"))
    n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pattern utilities

(defn clock-grid
  "Generates an impulse given beats per minute and a number of impulses
  per beat. The impulses are emitted evenly over the beat."
  [bpm res & flags]
  (let [bps (/ bpm 60.0)]
    (apply impulse (* bps res) flags)))

(defn sequencer
  [gate freqs]
  (let [node (add-node! (github.com$jfhamlin$muscrat$pkg$pattern.NewSequencer) "sequencer")
        gate (as-node gate)
        freqs (map as-node freqs)]
    (add-edge! gate node "trigger")
    (doseq-idx [[freq i] freqs]
               (add-edge! freq node (str \$ i)))
    node))

(defn trig-pattern
  [clock pattern]
  (let [s (sequencer clock pattern)]
    (* s clock)))

(defn choose
  [gate opts]
  (let [node (add-node! (github.com$jfhamlin$muscrat$pkg$pattern.NewChoose) "choose")
        gate (as-node gate)
        opts (map as-node opts)]
    (add-edge! gate node "trigger")
    (doseq-idx [[opt i] opts]
               (add-edge! opt node (str \$ i)))
    node))

(def choose-gate choose)
