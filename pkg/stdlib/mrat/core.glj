(ns mrat.core
  (:import (github.com$glojurelang$glojure$pkg$lang *Ratio *BigInt)
           (github.com$jfhamlin$muscrat$pkg$graph Node
                                                  WithLabel
                                                  WithSink)
           (github.com$jfhamlin$muscrat$pkg$ugen NewConstant
                                                 NewSum
                                                 NewProduct
                                                 NewFMA
                                                 NewFMAStatic
                                                 NewQuotient
                                                 NewAbs
                                                 NewExp
                                                 NewPow
                                                 NewCopySign
                                                 NewFreqRatio
                                                 NewMIDIFreq
                                                 NewImpulse
                                                 SimpleUGenFunc
                                                 WithAdd
                                                 WithMul
                                                 WithInterp
                                                 WithDefaultDutyCycle
                                                 InterpNone
                                                 InterpLinear
                                                 InterpCubic)
           (github.com$jfhamlin$muscrat$pkg$wavtabs Table)
           (github.com$jfhamlin$muscrat$pkg$osc NewSine
                                                NewSaw
                                                NewTri
                                                NewPulse
                                                NewPhasor
                                                NewLFSaw
                                                NewLFPulse)
           (github.com$jfhamlin$muscrat$pkg$stochastic NewNoise
                                                       NewNoiseQuad
                                                       NewPinkNoise)
           (github.com$jfhamlin$muscrat$pkg$mod NewEnvelope
                                                WithReleaseNode
                                                WithInterpolation)
           (github.com$jfhamlin$muscrat$pkg$effects NewAmplitude
                                                    NewFreeverb
                                                    NewBitcrusher
                                                    NewLimiter
                                                    NewLowpassFilter
                                                    NewRLPF
                                                    NewRHPF
                                                    NewBPF
                                                    NewLoShelf
                                                    NewHiShelf
                                                    NewPeakEQ
                                                    NewDelay
                                                    NewTapeDelay
                                                    NewWaveFolder
                                                    NewClip)
           (github.com$jfhamlin$muscrat$pkg$sampler NewSampler
                                                    LoadSample)
           (github.com$jfhamlin$muscrat$pkg$aio NewInputDevice
                                                NewSoftwareKeyboard
                                                NewMIDIInputDevice
                                                WithVoices
                                                WithDeviceID
                                                WithDeviceName
                                                WithChannel
                                                WithController
                                                WithDefaultValue
                                                NewWavOut)
           (github.com$jfhamlin$freeverb-go NewRevModel)))

(def SAMPLE-RATE github.com$jfhamlin$muscrat$pkg$conf.SampleRate)
(def BUFFER-SIZE github.com$jfhamlin$muscrat$pkg$conf.BufferSize)

(defmacro doseq-idx
  [[locals seq-expr] & body]
  `(let [s# ~seq-expr]
     (doseq [~locals (map vector s# (range (count s#)))]
       ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Graph

(def ^:dynamic *graph* nil)

(defprotocol AsNode
  "Protocol for types that can be converted to generator nodes."
  (as-node [ug]))

(declare add-edge!)

(defn add-node!
  [ug label & {:keys [sink in-edges]}]
  (let [node (if sink
               (.AddGeneratorNode *graph* ug (WithLabel (str label)) (WithSink))
               (.AddGeneratorNode *graph* ug (WithLabel (str label))))]
    (doseq [[port val] in-edges]
      (add-edge! (as-node val) node (name port)))
    node))

(defn add-edge!
  [x y port] (.AddEdge *graph* (.ID x) (.ID y) port))

(extend-protocol AsNode
  Node
  (as-node [n] n))

(extend-protocol AsNode
  go/float64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  go/int64
  (as-node [x] (add-node! (NewConstant x) x)))

(extend-protocol AsNode
  go/bool
  (as-node [x]
    (let [val (if x 1 0)]
      (add-node! (NewConstant val) (str x \- \( val \))))))

(extend-protocol AsNode
  *BigInt
  (as-node [x] (add-node! (NewConstant (double x)) x)))

(extend-protocol AsNode
  *Ratio
  (as-node [x] (add-node! (NewConstant (double x)) x)))

(defn play
  [channels]
  (let [channels (if-not (coll? channels) [channels channels] channels)
        channels (if (= (count channels) 0) [0 0] channels)
        channels (if (= (count channels) 1) [(first channels) (first channels)] channels)
        num-sinks (count (. *graph* outputs))
        ch-inds (map vector channels (range (count channels)))]
    (doseq [[ch i] ch-inds]
      (let [gen (as-node ch)
            chan-id (+ num-sinks i)
            sink (.AddOutNode *graph* (WithLabel (fmt.Sprintf "out%d" chan-id)))]
        (add-edge! gen sink "w"))))) ;; TODO: "w" seems wrong

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities

(defn pow
  "Returns b^e. If b or e are nodes, creates a new node that computes b^e. Else,
  returns the result of b^e directly."
  [b e]
  (if (some (partial instance? Node) [b e])
    (let [n (add-node! (NewPow) "pow")]
      (add-edge! (as-node b) n "base")
      (add-edge! (as-node e) n "exp")
      n)
    (math.Pow b e)))

(defn sine
  "Returns sin(theta). If theta is a node, creates a new node that
  computes sin(theta). Else, returns the result of sin(theta)
  directly."
  [theta]
  (if-not (instance? Node theta)
    (math.Sin theta)
    (let [n (add-node! (github.com$jfhamlin$muscrat$pkg$ugen.NewSine) "sine")]
      (add-edge! theta n "in")
      n)))

(defn abs
  "Returns the absolute value of x. If x is a node, creates a new node
  that computes the absolute value of x. Else, returns the absolute
  value of x directly."
  [x]
  (if (instance? Node x)
    (let [n (add-node! (NewAbs) "abs")]
      (add-edge! x n "in")
      n)
    (math.Abs x)))

(defn exp
  "Returns e^x. If x is a node, creates a new node that computes e^x.
  Else, returns e^x directly."
  [x]
  (if (instance? Node x)
    (let [n (add-node! (NewExp) "exp")]
      (add-edge! x n "in")
      n)
    (math.Exp x)))

(defn copy-sign
  "Returns x with the sign of s. If x or s are nodes, creates a new node
  that computes x with the sign of s. Else, returns x with the sign of
  s directly."
  [x s]
  (if (or (instance? Node x) (instance? Node s))
    (let [n (add-node! (NewCopySign) "copy-sign")]
      (add-edge! (as-node x) n "in")
      (add-edge! (as-node s) n "sign")
      n)
    (math.Copysign x s)))

(defn- freq-ratio
  [x kind]
  (let [n (add-node! (NewFreqRatio kind) kind)]
    (add-edge! x n "in")
    n))

(defn decibels
  "Return the amplitude ratio corresponding to the given decibel value."
  [db]
  (if (instance? Node db)
    (freq-ratio db "decibels")
    (pow 10 (/ db 20.0))))

(defn cents
  "Return the frequency ratio corresponding to the given number of
  cents."
  [x]
  (if (instance? Node x)
    (let [cnt (add-node! (NewFreqRatio "cents") "cents")]
      (add-edge! x cnt "in")
      cnt)
    (pow 2 (/ x 1200.0))))

(defn semitones
  "Return the frequency ratio corresponding to the given number of
  semitones."
  [x]
  (if (instance? Node x)
    (let [stn (add-node! (NewFreqRatio "semitones") "semitones")]
      (add-edge! x stn "in")
      stn)
    (pow 2 (/ x 12.0))))

(defn octaves
  "Return the frequency ratio corresponding to the given number of
  octaves."
  [x]
  (if (instance? Node x)
    (let [oct (add-node! (NewFreqRatio "octaves") "octaves")]
      (add-edge! x oct "in")
      oct)
    (pow 2 x)))

(defn midifreq
  "Return the frequency corresponding to the given MIDI note number."
  [note]
  (if (instance? Node note)
    (let [mf (add-node! (NewMIDIFreq) "midifreq")]
      (add-edge! note mf "in")
      mf)
    (* 440.0 (pow 2 (/ (- note 69.0) 12.0)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper for custom sample generators

(defn ugen-fn
  "Returns a UGenFunc that wraps the given function. The function should
  take a map of configuration parameters and an output buffer, and
  write samples to the output buffer."
  [f]
  (let [wrapped (fn [cfg out]
                  (f {:sample-rate-hz (.SampleRateHz cfg)
                      :input-samples (.InputSamples cfg)}
                     out))]
    (SimpleUGenFunc wrapped)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Operators

(defn- +-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-sum (apply glojure.core/+ nums)]
    (if (empty? ugens)
      num-sum
      (let [sum-node (add-node! (NewSum) "+")
            nodes (if (zero? num-sum)
                    ugens
                    (conj ugens (add-node! (NewConstant num-sum) num-sum)))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n sum-node (str \$ i)))
        sum-node))))

(defn +
  "Return the sum of any combination of numbers or ugens.
  If any argument to + is a node, then the result of + is a node.  If
  any argument to + is a collection, then the result is a collection
  whose length is the length of the longest collection (max-len) and
  where the elements of each argument are added pairwise. Any
  non-collections are duplicated to max-len, and any collections
  shorter than max-len are cycled up to max-len."
  ([] 0)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map + colls))
       (apply +-internal args)))))

(declare *)

(defn -
  "Return the difference of any combination of numbers or ugens.
  If any argument to - is a node, then the result of - is a node"
  ([] 0)
  ([x] (* -1 x))
  ([x & more] (+ x (apply + (map #(* -1 %) more)))))

(defn- *-internal
  [& xs]
  (let [groups (group-by #(instance? Node %) xs)
        nums (get groups false ())
        ugens (get groups true ())
        num-prod (apply glojure.core/* nums)]
    (if (empty? ugens)
      num-prod
      (let [prod-node (add-node! (NewProduct) "*")
            nodes (conj ugens (add-node! (NewConstant (double num-prod)) num-prod))]
        (doseq [[n i] (map vector nodes (range (count nodes)))]
          (add-edge! n prod-node (str \$ i)))
        prod-node))))

(defn *
  "Return the product of any combination of numbers or ugens.
  If any argument to * is a node, then the result of * is a node."
  ([] 1)
  ([x] x)
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map * colls))
       (apply *-internal args)))))

(defn- div-internal
  [& xs]
  (if (every? #(not (instance? Node %)) xs)
    (apply glojure.core// xs)
    (let [quot-node (add-node! (NewQuotient) "/")
          nodes (map as-node xs)]
      (doseq [[n i] (map vector nodes (range (count nodes)))]
        (add-edge! n quot-node (str \$ i)))
      quot-node)))

(defn /
  "Return the quotient of any combination of numbers or ugens.
  If any argument to / is a node, then the result of / is a node."
  ([x] (/ 1 x))
  ([x & more]
   (let [args (cons x more)]
     (if (some coll? args)
       (let [colls (map #(if (coll? %) % [%]) args)
             max-len (apply max (map count colls))
             colls (map #(take max-len (cycle %)) colls)]
         (apply map / colls))
       (apply div-internal args)))))

(defn sum
  [coll] (apply + coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; macros

(defn fma
  "A fused multiply and add ugen."
  [in mul add]
  (if (coll? in) ;; handle multiple channels
    (map #(fma % mul add) in)
    (if (and (every? number? [mul add])
             (== mul 1)
             (== add 0))
      in ;; no-op
      (let [node (if (every? number? [mul add])
                   (add-node! (NewFMAStatic mul add) "fma") ;; optimized for static mul and add
                   (let [n (add-node! (NewFMA) "fma")]
                     (add-edge! (as-node mul) n "mul")
                     (add-edge! (as-node add) n "add")
                     n))]
        (add-edge! (as-node in) node "in")
        node))))

(defmacro defugen
  "Defines a new generator node constructor with semantics similar to defn,
  but with specific constraints and enhancements for argument
  handling.  This macro allows only a single arity and requires the
  argument vector to be defined in pairs. Each pair consists of an
  argument name followed by its default value. When the resulting
  function is called, all parameters are optional; unprovided
  parameters default to their specified values. Additionally, callers
  can provide arguments out of their original order or skip certain
  arguments by using keyword-value pairs, where the keyword matches
  the argument name. This feature offers flexibility in how arguments
  are passed to the function, allowing for more dynamic and adaptable
  function calls."
  [name & decl]
  (let [[doc args & body] (if (string? (first decl))
                            decl
                            (cons "" decl))
        arg-pairs (partition 2 args)
        arg-names (mapv (comp keyword first) arg-pairs)
        defaults (into {} (map (fn [[k v]] [(keyword k) v]) arg-pairs))
        allowed-keys (merge (set (keys defaults)) :mul :add)
        assignments-sym (gensym "assignments")]
    `(defn ~name ~doc [& args#]
       (let [defaults# ~defaults
             ~assignments-sym (loop [assignments# {}
                                     arg-names# ~arg-names
                                     args# args#]
                                (if (or (empty? args#)
                                        (contains? ~allowed-keys (first args#)))
                                  (merge assignments# (apply hash-map args#))
                                  (if (empty? arg-names#)
                                    (throw (errors.New "too many positional arguments"))
                                    (recur (assoc assignments# (first arg-names#) (first args#))
                                           (rest arg-names#)
                                           (rest args#)))))
             ~assignments-sym (merge defaults# ~assignments-sym)
             ~@(mapcat (fn [[arg-name default]]
                         `(~arg-name (get ~assignments-sym ~(keyword arg-name))))
                       arg-pairs)
             ugen# (do ~@body)]
         (let [mul# (get ~assignments-sym :mul 1)
               add# (get ~assignments-sym :add 0)]
           (fma ugen# mul# add#))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Oscillators

(def default-freq 440)

(defn- validate-flags
  [flags defaults]
  (if (odd? (count flags))
    (throw (apply str "odd number of flag args: " (interpose \, flags))))
  (let [m (reduce #(apply assoc %1 %2) {} (partition 2 flags))
        unsupported (seq (remove (set (keys defaults)) (keys m)))]
    (if unsupported (throw (apply str "unsupported option(s) supplied: "
                                  (interpose \, unsupported))))
    (merge defaults m)))

(defn- handle-extra-gen-args
  [node args-map]
  (doseq [[k v] args-map]
    (let [gen (as-node v)
          param (k {:iphase "iphase"
                    :phase "phase"
                    :sync "sync"
                    :duty "dc"})]
      (when (nil? param) (throw (fmt.Errorf "handle-extra-gen-args: unknown parameter: %s" k)))
      (add-edge! gen node param))))

(defmacro defosc
  [name ctor & {:keys [default-duty] :or {default-duty 1}}]
  (let [opt-args '[duty iphase sync phase]]
    `(defugen ~name
       [~'freq default-freq
        ~@(mapcat #(vector % nil) opt-args)]
       (let [wt-opts# [(~'WithDefaultDutyCycle ~default-duty)]
             gen# (apply ~ctor wt-opts#)
             label# (~'WithLabel ~(str name))
             osc-node# (add-node! gen# label#)
             freq-node# (as-node ~'freq)
             extra-args# ~(mapv #(vector (keyword %) %) opt-args)
             extra-args# (into {} (remove (comp nil? second) extra-args#))]
         (add-edge! freq-node# osc-node# "w")
         (handle-extra-gen-args osc-node# extra-args#)
         osc-node#))))

(defosc sin NewSine)
(defosc saw NewSaw)
(defosc tri NewTri)
(defosc phasor NewPhasor)

(defosc pulse NewPulse :default-duty 0.5)
(defosc sqr NewPulse :default-duty 0.5)

(defosc lfsaw NewLFSaw)
(defosc lfpulse NewLFPulse :default-duty 0.5)
(defosc lfsqr NewLFPulse :default-duty 0.5)

(defugen impulse
  [freq default-freq
   iphase nil]
  (let [iphase (if iphase (as-node iphase))
        freq-node (as-node freq)
        node (add-node! (NewImpulse) "impulse")]
    (if iphase (add-edge! iphase node "iphase"))
    (add-edge! freq-node node "w")
    node))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Noise

(defugen noise
  "Generates random values between -1 and 1 at the given frequency.
  If frequency is zero or not provided, generates white
  noise."
  [freq 0]
  (add-node! (NewNoise) "noise" :in-edges {:w freq}))

(defugen pink-noise
  []
  (add-node! (NewPinkNoise) "pink-noise"))

(defugen noise-quad
  "Generates quadratically-interpolated random values between -1 and 1
  at the given frequency. If frequency is zero or not provided,
  generates at 500 hz."
  [freq 500]
  (add-node! (NewNoiseQuad) "noise-quad" :in-edges {:w freq}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Modulators

(defn env
  [gate levels times & flags]
  (let [flags (validate-flags flags {:interp :lin, :release-node -1})
        trigger (as-node gate)
        levels (map as-node levels)
        times (map as-node times)]
    (if (not= (count levels) (inc (count times)))
      (throw (str "env expects the number of levels to be one more than the number of times, got " (count levels) " levels and " (count times) " times.")))
    (let [env-node (add-node! (NewEnvelope
                               (WithInterpolation (subs (str (:interp flags)) 1))
                               (WithReleaseNode (:release-node flags)))
                              "envelope")]
      (add-edge! trigger env-node "trigger")
      (doseq [[n i] (map vector levels (range (count levels)))]
        (add-edge! n env-node (str "level$" i)))
      (doseq [[n i] (map vector times (range (count times)))]
        (add-edge! n env-node (str "time$" i)))
      env-node)))

(defn env-asr
  [gate [a s r]]
  (env gate [0 s 0] [a r] :release-node 1))

(defn env-adsr
  [gate [a d s r]]
  (env gate [0 1 s 0] [a d r] :release-node 2))

(defn env-perc
  [gate [a d]]
  (env gate [0 1 0] [a d]))

(defugen line
  "Generates a line from the start value to the end value over the given
  duration."
  [start 0
   end 1
   dur 1]
  (env 1 [start end] [dur] :interp :lin))

(defugen xline
  "Generates an exponential curve from the start value to the end
  value. Both the start and end values must be non-zero and have the
  same sign."
  [start 1
   end 2
   dur 1]
  (env 1 [start end] [dur] :interp :exp))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Filters and Effects

(defugen amplitude
  [in 0
   attack-time 0.01
   release-time 0.01]
  (add-node! (NewAmplitude attack-time release-time) "amplitude" :in-edges {:in in}))

(defugen limiter
  "Limits the input amplitude to the given level. Limiter will not
  overshoot, but it needs to look ahead in the audio. Thus there is a
  delay equal to twice the value of the dur parameter.

  Limiter is completely transparent for an in range signal.

  in - The signal to be processed.
  level - The peak output amplitude level to which to normalize the input.
  dur - aka lookAheadTime. The buffer delay time. Shorter times will
        produce smaller delays and quicker transient response times, but may
        introduce amplitude modulation artifacts."
  [in 0
   level 1
   dur 0.01]
  (add-node! (NewLimiter dur)
             "limiter"
             :in-edges {:in in
                        :amp level}))

(defn pipe
  "Create a pipe, which copies the input to the output. The input may be
  set with pipeset!. This is useful for creating feedback loops."
  []
  (let [f (fn [cfg out]
            (when-let [in (get (:input-samples cfg) "in")]
              (go/copy out in)))]
    (add-node! (ugen-fn f) "pipe")))

(defn pipeset!
  "Set the input of a pipe."
  [p in]
  (add-edge! (as-node in) p "in"))

(defn- freeverb-gen
  [& opts]
  (let [wet (get opts :wet 0.5)
        damp (get opts :damp 0.5)
        width (get opts :width 1.0)]
    (NewFreeverb
     (doto (NewRevModel)
       (.SetWet wet)
       (.SetDamp damp)
       (.SetWidth width)))))

(defn freeverb
  "A reverb effect. Options are:
  :dry - the amount of dry signal to mix in (0-1)
  :wet - the amount of wet signal to mix in (0-1)
  :room-size - the size of the room (0-1)
  :damp - the damping factor (0-1)"
  [node & opts]
  (let [opts (apply hash-map opts)
        supported #{:dry :wet :room-size :damp :width}
        unsupported (seq (remove supported (keys opts)))
        _ (if unsupported (throw (apply str "freeverb: unsupported option(s) supplied: "
                                        (interpose \, unsupported))))
        fv-node (add-node! (apply freeverb-gen opts) "freeverb")
        rs-node (as-node (get opts :room-size 0.5))
        dry-node (as-node (get opts :dry 0.5))]
    (add-edge! node fv-node "$0")
    (add-edge! rs-node fv-node "room-size")
    (add-edge! dry-node fv-node "dry")
    fv-node))

(defugen lores
  "A simple lowpass filter with cutoff and resonance, modeled after the
  Max/MSP lores~ object."
  [in 0
   freq 1200
   reson 0]
  (add-node! (NewLowpassFilter) "lores"
             :in-edges {:in in
                        :cutoff freq
                        :resonance reson}))

(defugen rlpf
  "A resonant low-pass filter."
  [in 0
   freq 440
   rq 1]
  (add-node! (NewRLPF) "rlpf"
             :in-edges {:in in
                        :freq freq
                        :reson rq}))

(defugen rhpf
  "A resonant high-pass filter."
  [in 0
   freq 440
   rq 1]
  (add-node! (NewRHPF) "rhpf"
             :in-edges {:in in
                        :freq freq
                        :reson rq}))

(defugen bpf
  "A simple bandpass filter with center frequency and bandwidth.
   n - the input signal
   freq - the center frequency in hertz
   rq - the width of the filter, as a coefficient bandwidth/freq"
  [in 0
   freq 440
   rq 1]
  (add-node! (NewBPF) "bpf"
             :in-edges {:in in
                        :w freq
                        :bw rq}))

(defugen loshelf
  [in 0
   freq 1200
   rs 1
   db 0]
  (add-node! (NewLoShelf) "loshelf"
             :in-edges {:in in
                        :w freq
                        :rs rs
                        :db db}))

(defugen hishelf
  [in 0
   freq 1200
   rs 1
   db 0]
  (add-node! (NewHiShelf) "hishelf"
             :in-edges {:in in
                        :w freq
                        :rs rs
                        :db db}))

(defugen peakeq
  [in 0
   freq 1200
   rq 1
   db 0]
  (add-node! (NewPeakEQ) "peakeq"
             :in-edges {:in in
                        :w freq
                        :rq rq
                        :db db}))

(defn- -delay
  [in max-delay-time delay-time interp-opt]
  (add-node! (NewDelay max-delay-time (WithInterp interp-opt)) "delay"
             :in-edges {:in in
                        :delay delay-time}))

(defugen delayn
  "Delay line with no interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2]
  (-delay in max-delay-time delay-time InterpNone))

(defugen delayl
  "Delay line with linear interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2]
  (-delay in max-delay-time delay-time InterpLinear))

(defugen delayc
  "Delay line with cubic interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2]
  (-delay in max-delay-time delay-time InterpCubic))

(defugen tape-delayl
  "Tape delay line with linear interpolation. This generator simulates
  a tape read head such that changes to the delay value are not
  instantaneous - the 'tape' is sped up or slowed down to reach the
  target delay time."
  [in 0
   delay-time 0.2]
  (add-node! (NewTapeDelay) "tape-delay"
             :in-edges {:$0 in
                        :delay delay-time}))

(defn- comb-feedback
  [delay-time decay-time]
  (if (or (and (not (instance? Node delay-time)) (zero? delay-time))
          (and (not (instance? Node decay-time)) (zero? decay-time)))
    0.0
    (let [abs-decay (abs decay-time)
          power (/ (* (math.Log 0.001) delay-time) abs-decay)
          absret (exp power)]
      (copy-sign absret decay-time))))

(defn- -comb
  [in max-delay-time delay-time decay-time delay-fn]
  (let [feedback (pipe)
        delay (delay-fn feedback max-delay-time delay-time)
        fb-coefficient (comb-feedback delay-time decay-time)
        comb (+ in (* fb-coefficient delay))]
    (pipeset! feedback comb)
    comb))

(defugen combn
  "Comb filter with no interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2
   decay-time 1]
  (-comb in max-delay-time delay-time decay-time delayn))

(defugen combl
  "Comb filter with linear interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2
   decay-time 1]
  (-comb in max-delay-time delay-time decay-time delayl))

(defugen combc
  "Comb filter with cubic interpolation."
  [in 0
   max-delay-time 0.2
   delay-time 0.2
   decay-time 1]
  (-comb in max-delay-time delay-time decay-time delayc))

(defugen clip
  "Clip an input signal when it exceeds threshold low/high values."
  [in 0
   lo -1
   hi 1]
  (if (some (partial instance? Node) [in lo hi])
    (add-node! (NewClip) "clip"
               :in-edges {:in in
                          :lo lo
                          :hi hi})
    (-> in
        (max lo)
        (min hi))))

(defugen pan2
  "A two-channel, equal-power panner."
  [in 0
   pos 0
   level 1]
  (let [pos (clip pos)
        pi4 (* math.Pi 0.25)
        pi2 (* math.Pi 0.5)
        theta (+ (* pi4 pos) pi4)
        lamp (* level (sine (- pi2 theta)))
        ramp (* level (sine theta))]
    [(* in lamp)
     (* in ramp)]))

(defugen wfold
  "Fold an input signal when it exceeds threshold low/high values.
  The signal is reflected across the low and high threshold values.
  Default low and high are -1 and 1."
  [in 0
   lo -1
   hi 1]
  (add-node! (NewWaveFolder) "wfold"
             :in-edges {:in in
                        :lo lo
                        :hi hi}))

(defugen bitcrush
  "Bitcrush an input signal."
  [in 0
   rate 44100
   bits 24]
  (add-node! (NewBitcrusher) "bitcrush"
             :in-edges {:in in
                        :rate rate
                        :bits bits}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sampler

(defn load-sample
  "Load an audio sample from a file into a buffer (slice of float64s) or
  a slice of buffers for multi-channel audio. The buffer will be
  resampled from the source to the engine's sample rate (available in
  the SAMPLE-RATE var). See play-buf for an example of how to play a
  loaded sample."
  [path] (LoadSample path))

(defugen play-buf
  "Play a buffer (single-channel) or slice of buffers (multi-channel)."
  [buf-or-bufs nil
   rate 1
   trigger 1
   start-pos 0
   loop 0]
  (when-not (pos? (count buf-or-bufs))
    (throw (errors.New "play-buf requires a non-empty buffer or slice of buffers")))
  (let [bufs (if (number? (first buf-or-bufs))
               [buf-or-bufs]
               buf-or-bufs)]
    (for [buf bufs]
      (add-node! (NewSampler buf) "play-buf"
                 :in-edges {:trigger trigger
                            :rate rate
                            :start-pos start-pos
                            :loop (or loop 0)}))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; I/O devices

(defn sound-in
  []
  (add-node! (NewInputDevice) "in"))

(defn qwerty-in
  [name & {:keys [voices]}]
  (let [num-voices (or voices 1)
        opts [(WithVoices num-voices)]
        kb (apply NewSoftwareKeyboard name opts)]
    (map (fn [i]
           {:note (add-node! (.Note kb i) (str "note-" i))
            :onoff (add-node! (.Gate kb i) (str "gate-" i))})
         (range num-voices))))

(defn midi-in
  "Registers one or more input ugens that emit values from MIDI events.
  The 'name' argument is a user-defined name for the input, which is
  used to identify the input in the user interface. The 'typ' argument
  is the type of event to track, one of:

  - :note - returns a seq, one element per voice (see flags), of
     maps with elements for note on/off (1/0), midi note number, and
     velocity: {:onoff <node> :note <node> :velocity <node>}
  - :bend - returns a single ugen node for the pitch bend value
  - :cc - returns a single ugen node for a single controller change
    value.
  - :after-touch - returns a single ugen node for mono aftertouch

  # Voices

  The :note input type is monophonic by default, with a single set of
  ugens tracking the latest note. To enable polyphony, provide the
  number of voices with the :voices flag. Notes on the mapped channel
  will be automatically allocated across the returned voices.

  # Device Mappings

  Input ugens can be (re-)mapped in the user interface, but the
  default mapping can be controlled with the following flags:

  - :device-id - The MIDI device ID, or a seq of IDs. If a seq, the
    first matching device in the seq is used. Default is 0.
  - :device-name - A regular expression to match against the device
    name.
  - :channel - The channel to map to. Default is 0.
  - :controller - For :cc type, the controller ID to map to. Default
    is 0."
  [name typ & flags]
  (let [_ (if-not (contains? #{:note :bend :cc :after-touch} typ)
            (throw (fmt.Errorf "unsupported midi-in type: %s" typ)))
        flags (validate-flags flags {:voices 1
                                     :device-id 0
                                     :device-name nil
                                     :channel 0
                                     :controller 0
                                     :default 0})
        num-voices (:voices flags)
        opts [(WithVoices num-voices)
              (WithDeviceID (:device-id flags))
              (WithChannel (:channel flags))
              (WithController (:controller flags))
              (WithDefaultValue (:default flags))]
        opts (if-let [name (:device-name flags)]
               (conj opts (WithDeviceName name))
               opts)
        dev (apply NewMIDIInputDevice name opts)]
    (case typ
      :note     (map #(do {:note (add-node! (.Note dev %) "midi-note")
                           :onoff (add-node! (.Gate dev %) "midi-gate")})
                     (range num-voices))
      :cc (add-node! (.Control dev) "midi-cc")
      (throw (fmt.Errorf "unsupported midi-in type: %s" typ))
      )))

(defn wavout
  "Save the input to a 32-bit wav file (up to two channels) named by
  the :filename flag (default out.wav)."
  [chs & flags]
  (let [chs (if (coll? chs) chs [chs])
        flags (validate-flags flags {:filename "out.wav"})
        _ (if (> (count chs) 2) (throw (str "wavout: too many channels supplied: " (count chs))))
        ch0 (as-node (first chs))
        ch1 (second chs)
        n (add-node! (NewWavOut (:filename flags)) "wavout" :sink true)]
    (add-edge! ch0 n "$0")
    (when ch1
      (add-edge! ch1 n "$1"))
    n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Pattern utilities

(defn clock-grid
  "Generates an impulse given beats per minute and a number of impulses
  per beat. The impulses are emitted evenly over the beat."
  [bpm res & flags]
  (let [bps (/ bpm 60.0)]
    (apply impulse (* bps res) flags)))

(defn sequencer
  [gate freqs]
  (let [node (add-node! (github.com$jfhamlin$muscrat$pkg$pattern.NewSequencer) "sequencer")
        gate (as-node gate)
        freqs (map as-node freqs)]
    (add-edge! gate node "trigger")
    (doseq-idx [[freq i] freqs]
               (add-edge! freq node (str \$ i)))
    node))

(defn trig-pattern
  [clock pattern]
  (let [s (sequencer clock pattern)]
    (* s clock)))

(defn choose
  [gate opts]
  (let [node (add-node! (github.com$jfhamlin$muscrat$pkg$pattern.NewChoose) "choose")
        gate (as-node gate)
        opts (map as-node opts)]
    (add-edge! gate node "trigger")
    (doseq-idx [[opt i] opts]
               (add-edge! opt node (str \$ i)))
    node))

(def choose-gate choose)
