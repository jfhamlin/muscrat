;;; Make some functions easier to use.
(def *sin mrat.osc.sin)
(def *saw mrat.osc.saw)
(def *sqr mrat.osc.sqr)
(def *tri mrat.osc.tri)
(def *phasor mrat.osc.phasor)
(def *noise mrat.osc.noise)

(def *lores mrat.effects.*lores)
(def *env mrat.effects.env)
(def *clip mrat.effects.clip)

(def print mrat.core.io.print)

(defn cons [car cdr] (concat (list car) cdr))

(defn flatten [lst]
  (if (empty? lst)
    lst
    (if (list? (first lst))
      (concat (flatten (first lst)) (flatten (rest lst)))
      (cons (first lst) (flatten (rest lst))))))

(defn oscrng [osc min max]
  (+ min
     (/ (- max min) 2)
     (* (/ (- max min) 2) osc)))

;;; Sawtooth wave but with a duty cycle parameter.
(def sawduty
  (fn [w duty & remainder]
    (let ((min (+ 1 (* -2 (*clip duty 0 1))))
          (max 1))
      (*clip (apply *saw (cons w remainder)) min max))))

;;; Helpers for grabbing key-value pairs from a list.
(defn getval [lst key]
  (if (or (nil? lst) (empty? lst))
    nil
    (if (not (list? key))
      (if (eq? (first lst) key)
        (first (rest lst))
        (getval (rest lst) key))
      (let ((val (getval lst (first key))))
        (if (nil? val)
          nil
          (if (empty? (rest key))
            val
            (getval val (rest key))))))))

(defn haskeyval? [lst key val]
  (if (nil? lst)
    #f
    (if (eq? (first lst) key)
      (if (eq? (first (rest lst)) val)
        #t
        (haskeyval? (rest lst) key val))
      (haskeyval? (rest lst) key val))))

(defn getvaldef [lst key def]
  (let ((v (getval lst key)))
    (if (nil? v)
      def
      v)))

;;; Generate sounds from configurations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Make a low-pass filter constructor.
(defn mklpf [cfg]
  (let ((cutoff (getvaldef cfg '(:lpf :cutoff) 1000))
        (res (getvaldef cfg '(:lpf :res) 0)))
    (fn [lfoinfo in]
      (*lores in (getlfocutoff lfoinfo cutoff) (getlfores lfoinfo res)))))

;;; Make an amplitude envelope constructor from a configuration. The
;;; returned constructor takes a gate signal and returns an envelope
;;; generator that is triggered by the gate.
(defn mkamp [cfg]
  (let ((ampcfg (getval cfg :amp)))
    (let ((attack (getvaldef ampcfg :attack 0))
          (decay (getvaldef ampcfg :decay 0))
          (sustain (getvaldef ampcfg :sustain 0))
          (release (getvaldef ampcfg :release 0)))
      (fn [gate] (*env gate (list 0 1 sustain 0) (list attack decay release)))))) ;; TODO: implement a real ADSR env

;; TODO: don't create phasors we don't need, and link up phasors to drive frequency of the dependent oscillators.

(defn getoscphasor [cfg w lfoinfo]
  (let ((detune (getvaldef cfg :detune 1)))
    (let ((w (* w detune))
          (osckey (getval cfg :key)))
      (let ((w (getlfofreq lfoinfo osckey w)))
        (list osckey (*phasor w))))))

;;; Make an oscillator constructor for the given configuration.
(defn mkosc [cfg]
  (fn [w lfoinfo]
    (let ((phasors (flatten (map (fn [oscCfg] (getoscphasor oscCfg w lfoinfo)) (getval cfg :osc)))))
      (let ((oscs (map (fn [cfg] (mk*osc cfg phasors)) (getval cfg :osc))))
        (sum (map (fn [*osc] (*osc w lfoinfo)) oscs))))))

;;; If the LFO is configured to target this oscillator's duty cycle,
;;; return the modulated duty cycle. Otherwise, return the original.
(defn getlfoduty [lfoinfo key duty]
  (let ((lfocfg (getval lfoinfo :cfg)))
    (if (not (haskeyval? (getval lfocfg :route) key :duty))
      duty
      (let ((*lfo (getval lfoinfo :lfo))
            (depth (getval (getval lfocfg :depth) :duty)))
        (* (+ 1 (* depth *lfo)) duty)))))

(defn getlfofreq [lfoinfo key w]
  (let ((lfocfg (getval lfoinfo :cfg)))
    (if (not (haskeyval? (getval lfocfg :route) key :freq))
        w
        (let ((*lfo (getval lfoinfo :lfo))
              (depth (getval (getval lfocfg :depth) :freq)))
          (* (oscrng *lfo (pow depth -1) depth) w)))))

(defn getlfocutoff [lfoinfo cutoff]
  (let ((lfocfg (getval lfoinfo :cfg)))
    (if (not (haskeyval? (getval lfocfg :route) :lpf :cutoff))
      cutoff
      (let ((*lfo (getval lfoinfo :lfo))
            (depth (getval lfocfg '(:depth :cutoff))))
        (* cutoff (+ 1 (* depth *lfo)))))))

(defn getlfores [lfoinfo res]
  (let ((lfocfg (getval lfoinfo :cfg)))
    (if (not (haskeyval? (getval lfocfg :route) :lpf :res))
      res
      (let ((*lfo (getval lfoinfo :lfo))
            (depth (getval lfocfg '(:depth :res))))
        (* res (+ 1 (* depth (oscrng *lfo -1 0))))))))

(defn getsyncargs [cfg phasors]
  (let ((syncosc (getval cfg :sync)))
    (if (nil? syncosc)
      nil
      (let ((syncph (getval phasors syncosc)))
        (list :sync syncph)))))

;;; Make an oscillator constructor from a configuration.
;;; - cfg is the configuration for this oscillator (not all).
;;; - phasors is a key-value list of phasor generators for other oscillators, used for sync.
(defn mk*osc [cfg phasors]
  (let ((wave (getvaldef cfg :wave :tri))
        (duty (getvaldef cfg :duty 0.5))
        (mix (getvaldef cfg :mix 1))
        (detune (getvaldef cfg :detune 1))
        (syncargs (getsyncargs cfg phasors)))
    (fn [w lfoinfo]
      (let ((w (* w detune))
            (osckey (getval cfg :key)))
        (let ((duty (getlfoduty lfoinfo osckey duty))
              (w    (getlfofreq lfoinfo osckey w)))
          (* mix (case wave
                   :tri (apply *tri (cons w syncargs))
                   :sqr (apply *sqr (concat (list w duty) syncargs))
                   :saw (apply sawduty (concat (list w duty) syncargs))
                   :sin (apply *sin (cons w syncargs))
                   :noise (*noise))))))))

;;; Make a low-frequency oscillator constructor from a configuration.
(defn mklfo [cfg]
  (if (nil? cfg)
    nil
    (let ((wave (getvaldef cfg '(:lfo :wave) :tri))
          (duty (getvaldef cfg '(:lfo :duty) 0.5))
          (w    (getvaldef cfg '(:lfo :freq) 0))) ;; default no lfo
      (fn [] (case wave
               :tri (*tri w)
               :sqr (*sqr w duty)
               :saw (*saw w)
               :sin (*sin w)
               :noise (noise))))))

;;; Make a sound generator from a configuration. Configuration
;;; structure is defined in Fred Welsh's "Welsh's Synthesizer
;;; Cookbook."
(defn mkwelsh [cfg]
  (let ((*lpf (mklpf cfg))
        (*osc (mkosc cfg))
        (*amp (mkamp cfg))
        (*lfo (mklfo cfg)))
    (fn [w gate]
      (let ((lfoinfo (list :lfo (*lfo) :cfg (getval cfg :lfo))))
        (* (*amp gate) (*lpf lfoinfo (*osc w lfoinfo)))
        )
      )
    )
  )

;;; how much should the lfo affect the cutoff frequency?
;;; example:
;;;
;;; if the filter is set to a magnitude of 2, and the lfo is set to a
;;; depth of 3, then the cutoff frequency will be modulated by a
;;; magnitude of 6. so you're adding more high frequencies to the
;;; signal.
;;;
;;; source: https://www.youtube.com/watch?v=n8qkVnkk8b8

;;; Configurations and sample generator constructors.

(def bongoConfig
  (list :osc (list (list :key :osc1
                         :wave :tri
                         :mix 1)
                   (list :key :osc2
                         :wave :sqr
                         :mix 0.65))
        :lpf (list :cutoff 600
                   :res 0
                   :env 0.6)
        :amp (list :attack 0.0001
                   :decay 0.22
                   :sustain 0
                   :release 0.22)))
(def bongo (mkwelsh bongoConfig))

;;; TODO: expose controls for modulating the cutoff frequency
;;; dynamically.
(def acidBassConfig
  (list :osc (list (list :key :osc1
                         :wave :sqr
                         :duty 0.25
                         :detune (cents 10)
                         :mix 0.7)
                   (list :key :osc2
                         :wave :sqr
                         :mix 1
                         :detune (* (octaves -2) (cents -10))))
        :lpf (list :cutoff 450
                   :res 0.6)
        :amp (list :attack 0.0001
                   :decay 0.45
                   :sustain 0.15
                   :release 0.26)))
(def acidBass (mkwelsh acidBassConfig))

;;; Dark Knight vibes.
(def darkCityConfig
  (list :osc (list (list :key :osc1
                         :wave :sqr
                         :duty 0.5
                         :detune (octaves -2)
                         :mix 1)
                   (list :key :osc2
                         :wave :saw
                         :detune (* (semitones -11) (cents -92))
                         :mix 1))
        :lfo (list :route '(:osc1 :duty :osc2 :duty)
                   :wave :sin
                   :freq 4
                   :depth '(:duty 0.45)) ;; TODO: confirm that we're interpreting this correctly for the duty cycle
        :lpf (list :cutoff 300
                   :res 0)
        :amp (list :attack 0.0001
                   :decay 3.9
                   :sustain 0.7
                   :release 6.35)))
(def darkCity (mkwelsh darkCityConfig))

(def vocalFemaleConfig
  (list :osc (list (list :key :osc1
                         :wave :sqr
                         :duty 0.05
                         :mix 1)
                   (list :key :osc2
                         :wave :sqr
                         :duty 0.25
                         :mix 0.65))
        :lfo (list :route '(:freq :freq)
                   :wave :tri
                   :freq 2.4
                   :depth (list :freq (cents 20)))
        :lpf (list :cutoff 1200
                   :res 0.5)
        :amp (list :attack 0.32
                   :decay  1 ;; author suggestion is max?
                   :sustain 1
                   :release 0.93)))
(def vocalFemale (mkwelsh vocalFemaleConfig))

(def vocalMaleConfig
  (list :osc (list (list :key :osc1
                         :wave :sqr
                         :duty 0.15
                         :detune (octaves -1)
                         :mix 1)
                   (list :key :osc2
                         :wave :sqr
                         :duty 0.25
                         :mix 0.9)) ;; TODO: mix in decibels, not absolute percentages...
        :lfo (list :route '(:freq :freq) ;; route to particular osc, not w/ global freq
                   :wave :tri
                   :freq 2.4
                   :depth (list :freq (cents 20)))
        :lpf (list :cutoff 1200
                   :res 0)
        :amp (list :attack 0.32
                   :decay  1 ;; author suggestion is max?
                   :sustain 1
                   :release 0.93)))
(def vocalMale (mkwelsh vocalMaleConfig))

(def androidDreamsConfig
  (list :osc (list (list :key :osc1
                         :wave :sqr
                         :duty 0.5
                         :detune (octaves -2)
                         :mix 1)
                   (list :key :osc2
                         :wave :saw
                         :mix 1
                         :detune (semitones -1)
                         :sync :osc1
                         )
                   (list :key :noise
                         :wave :noise
                         :mix 0.9))
        :lfo (list :route (list :osc1 :duty
                                :osc2 :duty
                                :osc2 :freq
                                :lpf :cutoff)
                   :wave :sin
                   :freq 0.25
                   :depth (list :duty .45
                                :cutoff .10
                                :freq (semitones 3)))
        :lpf (list :cutoff 2400
                   :res 0.3)
        :amp (list :attack 0.45
                   :decay 2
                   :sustain 1
                   :release 2.25)))
(def androidDreams (mkwelsh androidDreamsConfig))

(def celestialWashConfig
  (list :osc (list (list :key :noise
                         :wave :noise
                         :mix 1))
        :lfo (list :route (list :lpf :res)
                   :wave :sqr
                   :freq 5.5
                   :depth '(:res 1))
        :lpf (list :cutoff 1000
                   :res 1)
        :amp (list :attack 1.65
                   :decay 5.85
                   :sustain 0
                   :release 4.40)))
(def celestialWash (mkwelsh celestialWashConfig))
